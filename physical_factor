# /home/ystatter/virunga/maths/sparse/spfactor.c
542:  *  Sparse operates on a row-at-a-time basis.  For speed, on each
# /home/ystatter/virunga/maths/sparse/spsmp.c
318:     spDeterminant( Matrix, pExponent, &(pMantissa->real),
319:                                               &(pMantissa->imag) );
395:     pMantissa->real = scalbn(re, (int) -y);
396:     pMantissa->imag = scalbn(im, (int) -y);
399:     printf("Determinant 10->2: (%20g,%20g)^%d\n", pMantissa->real,
400: 	pMantissa->imag, *pExponent);
# /home/ystatter/virunga/maths/cmaths/test_cx_cph.c
19:     return fabs(a-b) < eps;
# /home/ystatter/virunga/maths/cmaths/cmath1.c
764:     if (aa->amplitude > bb->amplitude)
766:     else if (aa->amplitude == bb->amplitude)
# /home/ystatter/virunga/maths/misc/bernoull.c
18:  * input    delta-psi 
# /home/ystatter/virunga/bdb/db-6.0.30/lang/tcl/tcl_db.c
3318: 	dobj = Tcl_NewByteArrayObj(data->data, (int)data->size);
3423: 	dobj = Tcl_NewByteArrayObj(data->data, (int)data->size);
3448: 	orig_len = (size_t)data->size;
3449: 	if((len == orig_len) && (memcmp(retbuf, data->data, len) == 0)) {
3455: 			memcpy(data->data, retbuf, len);
3456: 			data->size = (u_int32_t)len;
3459: 			    sdbp->env, len, &data->data)) != 0)
3461: 			memcpy(data->data, retbuf, len);
3462: 			data->size = (u_int32_t)len;
4334: 	ip->i_cdata->compact_fillpercent = fillfactor;
4335: 	ip->i_cdata->compact_timeout = timeout;
4336: 	ip->i_cdata->compact_pages = pages;
# /home/ystatter/virunga/bdb/db-6.0.30/lang/tcl/tcl_db_pkg.c
5061: 	a = Tcl_NewByteArrayObj(dbta->data, (int)dbta->size);
5208: 	objv[1] = Tcl_NewByteArrayObj(data->data, (int)data->size);
5530: 	seckey->data = data->data;
5531: 	seckey->size = data->size;
# /home/ystatter/virunga/bdb/db-6.0.30/lang/db185/db185.c
551: 	a185.data = a->data;
552: 	a185.size = a->size;
570: 	a185.data = a->data;
571: 	a185.size = a->size;
# /home/ystatter/virunga/bdb/db-6.0.30/build_vxworks/util/db_load.c
708: 	offset = data->size;
715: 		data->flags |= DB_DBT_BLOB;
735: 	if (data->ulen < MEGABYTE) {
736: 		if ((data->data = realloc(
737: 		    data->data, data->ulen = MEGABYTE)) == NULL) {
748: 		if (db_load_dbt_rdump(dbenv, data, data->ulen, &streaming)) {
756: 		offset += data->size;
# /home/ystatter/virunga/bdb/db-6.0.30/build_vxworks/db_config_small.h
317: /* Define to 1 to configure mutexes intra-process only. */
# /home/ystatter/virunga/bdb/db-6.0.30/build_vxworks/db_int.h
996: 	if (c_data->compact_truncate > 1)		\
997: 		c_data->compact_truncate--;		\
# /home/ystatter/virunga/bdb/db-6.0.30/build_vxworks/db.h
207: /* Key/data structure -- a Data-Base Thang. */
# /home/ystatter/virunga/bdb/db-6.0.30/build_vxworks/db_config.h
317: /* Define to 1 to configure mutexes intra-process only. */
# /home/ystatter/virunga/bdb/db-6.0.30/util/db_sql_codegen/utils.c
126: ** brackets from around identifers.  For example:  "[a-b-c]" becomes
127: ** "a-b-c".
# /home/ystatter/virunga/bdb/db-6.0.30/util/db_sql_codegen/generate_verification.c
420: 	if (is_array(a->type) && !is_string(a->type)) {
422: 	} else if (is_string(a->type)) {
423: 		if (a->type->array_dim < 12)
427: 	} else if (strcmp(a->type->c_type, "char") == 0 ||
428: 	    strcmp(a->type->c_type, "short") == 0 ||
429: 	    strcmp(a->type->c_type, "int") == 0 ||
430: 	    strcmp(a->type->c_type, "long") == 0) {
432: 	} else if (strcmp(a->type->c_type, "float") == 0 ||
433: 	    strcmp(a->type->c_type, "scalar") == 0) {
437: 		    "Unexpected C type in schema: %s", a->type->c_type);
519: 	    idx->primary->name, a->name);
526: 	    idx->primary->name, a->name,
527: 	    idx->primary->name, a->name);
529: 	if (is_array(a->type) && !is_string(a->type)) {
536: 		if (is_string(a->type)) {
539: 			    idx->primary->name, a->name,
540: 			    idx->primary->name, a->name);
541: 		} else if ((strcmp(a->type->c_type, "float") == 0) ||
542: 		    (strcmp(a->type->c_type, "scalar") == 0)) {
545: 			    idx->primary->name, a->name,
546: 			    idx->primary->name, a->name);
550: 			    idx->primary->name, a->name,
551: 			    idx->primary->name, a->name);
599: 	if (is_array(a->type) && !is_string(a->type))
602: 		pr_test("%s_record_array[i].%s", e->name, a->name);
666: 	if (is_array(a->type) && !is_string(a->type)) {
668: 		    e->name, a->name, array_dim_name(e, a), a->name);
669: 	} else if (is_string(a->type)) {
672: 		    e->name, a->name, e->name, a->name);
673: 	} else if ((strcmp(a->type->c_type, "float") == 0) ||
674: 	    (strcmp(a->type->c_type, "scalar") == 0)) {
677: 		    e->name, a->name, e->name, a->name);
680: 		    e->name, a->name, e->name, a->name);
731: 	if (is_array(a->type) && !is_string(a->type)) {
733: 		    e->name, a->name, array_dim_name(e, a));
734: 	} else if (is_string(a->type)) {
737: 		    e->name, a->name, e->name, a->name);
738: 	} else if ((strcmp(a->type->c_type, "float") == 0) ||
739: 	    (strcmp(a->type->c_type, "scalar") == 0)) {
742: 		    e->name, a->name, e->name, a->name);
745: 		    e->name, a->name, e->name, a->name);
771: 	key = data_value_for_type(a->type);
776: 	if (is_string(a->type)) {
777: 		if (a->type->array_dim < 12)
781: 	} else if (is_array(a->type)) {
783: 	} else if (strcmp(a->type->c_type, "char") == 0 ||
784: 	    strcmp(a->type->c_type, "short") == 0 ||
785: 	    strcmp(a->type->c_type, "int") == 0 ||
786: 	    strcmp(a->type->c_type, "long") == 0) {
788: 	} else if (strcmp(a->type->c_type, "float") == 0 ||
789: 	    strcmp(a->type->c_type, "scalar") == 0) {
793: 		    "Unexpected C type in schema: %s", a->type->c_type);
# /home/ystatter/virunga/bdb/db-6.0.30/util/db_sql_codegen/generate.c
254:  memcpy(&ai, a->data, sizeof(int));                                         \n\
265:  memcpy(&ai, a->data, sizeof(long));                                        \n\
369: 	if (is_array(a->type))
371: 		    a->type->array_dim);
400: 	pr_header("%s\t%s;\n", a->type->c_type, decl_name(e, a));
428: 	if (strcmp(e->primary_key->name, a->name) == 0)
432: 		    e->name, a->name);
556: 	if (strcmp(e->primary_key->name, a->name) != 0) {
561: 		if (is_string(a->type)) {
563: 			    e->name, a->name,
565: 			    e->name, a->name);
568: 			    is_array(a->type) ? "" : "&",
569: 			    e->name, a->name, e->name, a->name);
570: 			pr_code("p += sizeof(%sp->%s);\n", e->name, a->name);
623: 		if (strcmp(e->primary_key->name, a->name) != 0) {
624: 			if (is_string(a->type)) {
627: 				    e->name, a->name);
631: 				    is_array(a->type)? "" : "&",
632: 				    e->name, a->name, e->name, a->name);
634: 				    e->name, a->name);
725: 		pr_header("%s %s%s", a->type->c_type,
726: 		    is_array(a->type)? "*" : "",
727: 		    a->name);
744: 	pr_code("%s %s%s", a->type->c_type,
745: 	    is_array(a->type)? "*" : "",
746: 	    a->name);
794: 	if (is_string(a->type)) {
795: 		pr_code("assert(strlen(%s) < %s);\n", a->name,
798: 		    a->name, a->name, array_dim_name(e, a));
799: 	} else if (is_array(a->type)) {
801: 		    a->name, a->name, array_dim_name(e, a));
803: 		pr_code("data.%s = %s;\n", a->name, a->name);
876:  memcpy(&data->%s, key_dbt.data, sizeof(data->%s));			    \n\
# /home/ystatter/virunga/bdb/db-6.0.30/util/db_sql_codegen/generation_utils.c
130: 	for (a = e->attributes_head; a; a = a->next)
132: 			(*a_op)(e, a, a == e->attributes_head, a->next == NULL);
215: 	if (a->array_dim_name != NULL)
216: 		return a->array_dim_name;
221: 	len += strlen(a->name);
225: 	snprintf(s, len, format, e->name, a->name);
229: 	a->array_dim_name = s;
235: 	return a->array_dim_name;
246: 	if (a->decl_name != NULL)
247: 		return a->decl_name;
249: 	if (!is_array(a->type))
250: 		a->decl_name = a->name;
256: 		len += strlen(a->name);
261: 		snprintf(s, len, format, a->name, dim_name);
264: 		a->decl_name = s;
267: 	return a->decl_name;
# /home/ystatter/virunga/bdb/db-6.0.30/util/db_sql_codegen/buildpt.c
245: 	for (a = in_entity->attributes_head; a; a = a->next)
246: 		if (strcasecmp(sought_name, a->name) == 0)
802: 		    get_current_entity()->name, pFromCol->a->zName,
803: 		    s, pToCol->a->zName);
842: 	entity_name = pTblName->a->zName;
843: 	attribute_name = pList->a->zName;
# /home/ystatter/virunga/bdb/db-6.0.30/util/db_sql_codegen/generate_test.c
436: 	pr_test("%s", data_value_for_type(a->type));
452: 	pr_test("printf(\"%s->%s: ", e->name, a->name);
454: 	pr_test("%s", format_string_for_type(a->type));
456: 	if (is_array(a->type) && !is_string(a->type)) {
458: 		    e->name, a->name, array_dim_name(e, a) );
460: 		pr_test("\\n\", %s_record->%s);\n", e->name, a->name);
518: 	pr_test("printf(\"%s.%s: ", e->name, a->name);
520: 	pr_test("%s", format_string_for_type(a->type));
522: 	if (is_array(a->type) && !is_string(a->type)) {
524: 		    e->name, a->name, array_dim_name(e, a) );
526: 		pr_test("\\n\", %s_record.%s);\n", e->name, a->name);
# /home/ystatter/virunga/bdb/db-6.0.30/util/db_load.c
693: 	offset = data->size;
700: 		data->flags |= DB_DBT_BLOB;
720: 	if (data->ulen < MEGABYTE) {
721: 		if ((data->data = realloc(
722: 		    data->data, data->ulen = MEGABYTE)) == NULL) {
733: 		if (dbt_rdump(dbenv, data, data->ulen, &streaming)) {
741: 		offset += data->size;
# /home/ystatter/virunga/bdb/db-6.0.30/build_windows/db_int.h
993: 	if (c_data->compact_truncate > 1)		\
994: 		c_data->compact_truncate--;		\
# /home/ystatter/virunga/bdb/db-6.0.30/build_windows/db.h
251: /* Key/data structure -- a Data-Base Thang. */
# /home/ystatter/virunga/bdb/db-6.0.30/build_windows/db_config.h
322: /* Define to 1 to configure mutexes intra-process only. */
# /home/ystatter/virunga/bdb/db-6.0.30/test/c/test_db185.c
78: 	len = a->size > b->size ? b->size : a->size;
79: 	for (p1 = a->data, p2 = b->data; len--; ++p1, ++p2)
82: 	return ((long)a->size - (long)b->size);
# /home/ystatter/virunga/bdb/db-6.0.30/test/tcl/sec002.tcl
101: 	puts "\tSec002.c: Overwrite unused space in meta-page"
# /home/ystatter/virunga/bdb/db-6.0.30/test/tcl/env020.tcl
434: 		{\d*, #\d*,\s*\d*,\s*\d*/\d*, 0[xX][0-9a-fA-F]*, \d*}
# /home/ystatter/virunga/bdb/db-6.0.30/test/tcl/rep003.tcl
113: 	rep003_put $masterenv A1 a-one
124: 	rep003_put $masterenv A2 a-two
131: 	rep003_check $clientenv A1 a-one
132: 	rep003_check $clientenv A2 a-two
152: 	rep003_check $clientenv A1 a-one
153: 	rep003_check $clientenv A2 a-two
167: 		rep003_check $clientenv A1 a-one
168: 		rep003_check $clientenv A2 a-two
196: 	rep003_check $clientenv A1 a-one
197: 	rep003_check $clientenv A2 a-two
210: 		rep003_check $clientenv A1 a-one
211: 		rep003_check $clientenv A2 a-two
250: 		rep003_check $clientenv A1 a-one
251: 		rep003_check $clientenv A2 a-two
# /home/ystatter/virunga/bdb/db-6.0.30/test/tcl/sdb018.tcl
67: 		puts "Subdb018: $method ( $args ) Intra-subdb join"
73: 		puts "\tSubdb018.a: Intra-subdb join"
# /home/ystatter/virunga/bdb/db-6.0.30/test/tcl/testutils.tcl
2942: 	# chances;  sleep extra-long so that when tclsleep 1 returns,
# /home/ystatter/virunga/bdb/db-6.0.30/test/tcl/sdb006.tcl
8: # TEST	Tests intra-subdb join
67: 		puts "Subdb006: $method ( $args ) Intra-subdb join"
73: 		puts "\tSubdb006.a: Intra-subdb join"
# /home/ystatter/virunga/bdb/db-6.0.30/test/tcl/rep034.tcl
316: 	# scanning the data-dir during UPDATE_REQ processing (which, remember,
# /home/ystatter/virunga/bdb/db-6.0.30/test/tcl/rep007.tcl
178: 	# We need to do a deletion here to cause meta-page updates,
# /home/ystatter/virunga/bdb/db-6.0.30/test/tcl/test131.tcl
380: 		set ret [eval $foreign_db put $txn $key $data-NEW]
# /home/ystatter/virunga/bdb/db-6.0.30/src/blob/blob_stream.c
181: 		data->size = 0;
188: 	data->size = needed;
262: 	if (offset + (off_t)data->size < offset) {
266: 		"%lu %lld"), (u_long)data->size, (long long)offset);
# /home/ystatter/virunga/bdb/db-6.0.30/src/blob/blob_util.c
194: 	 * file: blob directory/meta-file-name
195: 	 * else: blob directory/per-db-blobdir/meta-file-name
793: 				meta->locker = NULL;
# /home/ystatter/virunga/bdb/db-6.0.30/src/xa/xa.c
297:  * initialization.  The file xa_map.c implements all such xa->db mappings.
# /home/ystatter/virunga/bdb/db-6.0.30/src/mp/mp_bh.c
363: 	 * Two special cases.  There is a single field on the meta-data page,
# /home/ystatter/virunga/bdb/db-6.0.30/src/crypto/crypto.c
265: 	 * We used an "unused" field in the meta-data page to flag whether or
279: 	if (meta->magic == DB_HASHMAGIC && meta->version <= 5)
283: 	 * Meta-pages may be encrypted for DBMETASIZE bytes.  If we have a
297: 	if (meta->encrypt_alg != 0) {
322: 		    meta->encrypt_alg != db_cipher->alg) {
348: 			if (((BTMETA *)meta)->crypto_magic != meta->magic) {
366: 		ret = __crypto_algsetup(env, db_cipher, meta->encrypt_alg, 1);
# /home/ystatter/virunga/bdb/db-6.0.30/src/repmgr/repmgr_util.c
721: 	/* Write the meta-data record. */
# /home/ystatter/virunga/bdb/db-6.0.30/src/repmgr/repmgr_msg.c
224: 	 * However, there's also our meta-data tacked on to the end of it.
225: 	 * Fortunately, the meta-data is fixed length, so it's easy to peel it
305: 	RESP_ERROR_TAG(msg_hdr) = channel->meta->tag;
# /home/ystatter/virunga/bdb/db-6.0.30/src/repmgr/repmgr_method.c
2155: 		APP_RESP_TAG(msg_hdr) = channel->meta->tag;
2167: 		APP_RESP_TAG(msg_hdr) = channel->meta->tag;
2178: 	    (APP_RESP_BUFFER_SIZE(msg_hdr) > channel->meta->limit)) {
2290: 	 * (d) message meta-data (optionally)
# /home/ystatter/virunga/bdb/db-6.0.30/src/fileops/fop_util.c
34:  * Acquire the environment meta-data lock.  The parameters are the
323: 		 * mpool open to read the meta-data page, so we're going to
369: 		/* Cases 1,3-5: we need to read the meta-data page. */
581: 	 * routines to create meta-data pages.  For in-memory files, we retain
804:  * the meta-data page will suffice to protect us from simultaneous operations
807:  * while we've got it open.  We use an object that looks like the meta-data
886: 	 * the same file in mpool.  We'll use the meta-pgno to lock
915: 	 * meta-data page and set information in the DB handle based on it.
1040: 	 * read the meta-data page and get the fileid so that we can lock
1054: 	/* Get meta-data */
1122:  *	Read the meta-data page from a file and return it in buf.
1503: 	/* Copy the fileid onto the meta-data page. */
# /home/ystatter/virunga/bdb/db-6.0.30/src/fileops/fop_rec.c
108: 				    meta->uid, NULL, real_name, NULL, 0)) != 0)
190: 				    meta->uid, NULL, real_name, NULL, 0)) != 0)
349: 				    old_data->data, old_data->size, &nbytes);
363: 			    NULL, offset, new_data->data, new_data->size, 0);
584: 		 * exist, doesn't have a meta-data page, or is in some other
595: 		if (memcmp(argp->fileid.data, meta->uid, DB_FILE_ID_LEN) != 0)
612: 			    meta->uid, DB_FILE_ID_LEN) != 0) {
716: 		 * exist, doesn't have a meta-data page, or is in some other
727: 		if (memcmp(argp->fileid.data, meta->uid, DB_FILE_ID_LEN) != 0)
744: 			    meta->uid, DB_FILE_ID_LEN) != 0) {
824: 		 * in it, but that something isn't a full meta-data page, so
839: 		    memcmp(argp->real_fid.data, meta->uid, DB_FILE_ID_LEN) == 0;
841: 		    memcmp(argp->tmp_fid.data, meta->uid, DB_FILE_ID_LEN) == 0;
# /home/ystatter/virunga/bdb/db-6.0.30/src/common/db_err.c
802: 	 * vica-versa.  This happens all the time as the dbp during
# /home/ystatter/virunga/bdb/db-6.0.30/src/common/dbt.c
71: 	    F_ISSET(data, DB_DBT_USERCOPY) && data->data != NULL) {
72: 		__os_ufree(env, data->data);
73: 		data->data = NULL;
# /home/ystatter/virunga/bdb/db-6.0.30/src/txn/txn_stat.c
432: 	if (a->txnid > b->txnid)
434: 	if (a->txnid < b->txnid)
# /home/ystatter/virunga/bdb/db-6.0.30/src/rep/rep_backup.c
530: 	 * the client can compute the pages from the meta-data.
535: 		rfp->max_pgno = dbmeta->last_pgno;
1873: 	 * queue database.  Since the meta-page is always in the queue file,
3001:  *	2.  We use the meta-page information to figure out first and last
3077: 	 * 1.  We have received the meta-page and now need to get the
3104: 		 * meta-page, now we need pages 1-max_pgno.
# /home/ystatter/virunga/bdb/db-6.0.30/src/hmac/sha1.c
13: By Steve Reid <sreid@sea-to-sky.net>
55: By Steve Reid <sreid@sea-to-sky.net>
60: 3- Changed email address from steve@edmweb.com to sreid@sea-to-sky.net
# /home/ystatter/virunga/bdb/db-6.0.30/src/btree/bt_stat.c
72: 	for (sp->bt_free = 0, pgno = meta->dbmeta.free; pgno != PGNO_INVALID;) {
158: 			sp->bt_nkeys = meta->dbmeta.key_count;
161: 		   sp->bt_nkeys : meta->dbmeta.record_count;
165: 	sp->bt_metaflags = meta->dbmeta.flags;
166: 	sp->bt_minkey = meta->minkey;
167: 	sp->bt_re_len = meta->re_len;
168: 	sp->bt_re_pad = meta->re_pad;
170: 	 * Don't take the page number from the meta-data page -- that value is
172: 	 * a subdatabase.  (Yes, I read the primary database meta-data page
179: 	sp->bt_pagesize = meta->dbmeta.pagesize;
180: 	sp->bt_magic = meta->dbmeta.magic;
181: 	sp->bt_version = meta->dbmeta.version;
184: 		meta->dbmeta.key_count = sp->bt_nkeys;
185: 		meta->dbmeta.record_count = sp->bt_ndata;
# /home/ystatter/virunga/bdb/db-6.0.30/src/btree/bt_compress.c
172: 	data->data = stream->data->data;
173: 	data->size = stream->data->size;
198: 		data->data = NULL;
199: 		data->size = 0;
225: 		data->data, data->size);
254: 	DB_MULTIPLE_NEXT(stream->dptr, stream->data, data->data, data->size);
255: 	if (key->data == NULL || data->data == NULL) {
290: 		data->data = NULL;
291: 		data->size = 0;
328: 	destbuf->size = __db_compress_count_int(data->size);
329: 	destbuf->size += data->size;
334: 	ptr += __db_compress_int(ptr, data->size);
335: 	memcpy(ptr, data->data, data->size);
421: 		k = (const u_int8_t*)data->data;
422: 		p = (const u_int8_t*)prevData->data;
423: 		len = data->size > prevData->size ? prevData->size : data->size;
427: 		prefix = (size_t)(k - (u_int8_t*)data->data);
428: 		suffix = data->size - prefix;
456: 		__db_compress_count_int(data->size) + suffix + data->size);
468: 	ptr += __db_compress_int(ptr, data->size);
475: 	memcpy(ptr, data->data, data->size);
520: 		destData->size = prefix + suffix;
522: 			destData->size > destData->ulen)
529: 		if (prefix > prevData->size)
531: 		d = (u_int8_t*)destData->data;
532: 		memcpy(d, prevData->data, prefix);
561: 	s += __db_decompress_int32(s, &destData->size);
565: 	if (destKey->size > destKey->ulen || destData->size > destData->ulen)
583: 	size += destData->size;
586: 	memcpy(destData->data, s, destData->size);
587: 	s += destData->size;
889: 			     &cp_n->del_data, cp->currentData->data,
890: 			     cp->currentData->size)) != 0)
1247: 				    &pdestdata, cp->currentData->data,
1248: 				    cp->currentData->size)) != 0)
1459: 				     &pdestdata, cp->currentData->data,
1460: 				     cp->currentData->size)) != 0)
1973: 		writedata, cp->currentData->size);
1975: 		data->size = cp->currentKey->size + cp->currentData->size +
1982: 	memcpy(writedata, cp->currentData->data, cp->currentData->size);
1986: 		    cp->currentKey->size, writedata, cp->currentData->size);
1996: 		memcpy(writedata, cp->currentData->data, cp->currentData->size);
2027: 	data->size = 0;
2030: 	DB_MULTIPLE_RESERVE_NEXT(mptr, data, writedata, cp->currentData->size);
2031: 	data->size += cp->currentData->size + 2 * sizeof(u_int32_t);
2035: 	memcpy(writedata, cp->currentData->data, cp->currentData->size);
2039: 		    mptr, data, writedata, cp->currentData->size);
2040: 		data->size += cp->currentData->size + 2 * sizeof(u_int32_t);
2051: 		memcpy(writedata, cp->currentData->data, cp->currentData->size);
2162: 				cp->currentData->data, cp->currentData->size,
2163: 				&dbc->rdata->data, &dbc->rdata->ulen);
2479: 		     cp->currentData->data, cp->currentData->size)) != 0)
2771: 		    orig->currentData->data, orig->currentData->size)) != 0)
2782: 			    orig->prevData->data, orig->prevData->size)) != 0)
2854: 	compcursor = (u_int8_t*)data->data;
2855: 	compend = compcursor + data->size;
2857: 	if (data->size == 0) {
# /home/ystatter/virunga/bdb/db-6.0.30/src/btree/bt_upgrade.c
46: 	newmeta->re_pad = oldmeta->re_pad;
47: 	newmeta->re_len = oldmeta->re_len;
48: 	newmeta->minkey = oldmeta->minkey;
49: 	newmeta->maxkey = oldmeta->maxkey;
50: 	newmeta->dbmeta.free = oldmeta->free;
51: 	newmeta->dbmeta.flags = oldmeta->flags;
52: 	newmeta->dbmeta.type  = P_BTREEMETA;
54: 	newmeta->dbmeta.version = 7;
59: 	newmeta->root = 1;
95: 	newmeta->root = oldmeta->root;
96: 	newmeta->re_pad = oldmeta->re_pad;
97: 	newmeta->re_len = oldmeta->re_len;
98: 	newmeta->minkey = oldmeta->minkey;
99: 	newmeta->maxkey = oldmeta->maxkey;
100: 	memmove(newmeta->dbmeta.uid,
101: 	    oldmeta->dbmeta.uid, sizeof(oldmeta->dbmeta.uid));
102: 	newmeta->dbmeta.flags = oldmeta->dbmeta.flags;
103: 	newmeta->dbmeta.record_count = 0;
104: 	newmeta->dbmeta.key_count = 0;
105: 	ZERO_LSN(newmeta->dbmeta.unused3);
108: 	newmeta->dbmeta.version = 8;
112: 		F_SET(&newmeta->dbmeta, BTM_DUPSORT);
158:  * __bam_60_btreemeta--
181: 	bmeta->dbmeta.version = 10;
# /home/ystatter/virunga/bdb/db-6.0.30/src/btree/bt_compare.c
234: 	p1 = (u_int8_t *)a->data + start;
236: 	len = a->size > b->size ? b->size : a->size;
245: 	return (a->size == b->size ? 0 : (a->size < b->size ? -1 : 1));
265: 	len = a->size > b->size ? b->size : a->size;
266: 	for (p1 = a->data, p2 = b->data; len--; ++p1, ++p2, ++cnt)
274: 	if (a->size < b->size)
275: 		return (a->size + 1);
276: 	if (b->size < a->size)
# /home/ystatter/virunga/bdb/db-6.0.30/src/btree/bt_recno.c
1034: 	rdata->flags = 0;
1035: 	rdata->size = 0;
1272: 	if (rdata->ulen < len) {
1274: 		    dbp->env, len, &rdata->data)) != 0) {
1275: 			rdata->ulen = 0;
1276: 			rdata->data = NULL;
1279: 		rdata->ulen = (u_int32_t)len;
1284: 		data.data = rdata->data;
1306: 				if (data.size == rdata->ulen) {
1308: 					    rdata->ulen *= 2,
1309: 					    &rdata->data)) != 0) {
1310: 						rdata->ulen = 0;
1311: 						rdata->data = NULL;
1314: 						data.data = rdata->data;
# /home/ystatter/virunga/bdb/db-6.0.30/src/btree/bt_put.c
110: 	    F_ISSET(data, DB_DBT_PARTIAL) && data->size != data->dlen)
111: 		return (__db_rec_repl(env, data->size, data->dlen));
126: 		data_size = data->size;
156: 		    data->doff == ((BOVERFLOW *)bk)->tlen) {
163: 			    cp->stream_off > data->doff || data->doff >
166: 				tdbt.doff = data->doff - 1;
195: 			tdbt.dlen = data->size;
490: 			bk_tmp.len = data->size;
494: 			    BKEYDATA_SIZE(data->size), &bk_hdr, data);
510: 					blob_dbt.data = BBLOB_DATA(data->data);
551: 				    BKEYDATA_SIZE(data->size), NULL, data);
624: 		*data_size = data->doff + data->size;
687: 	if (rdata->ulen < nbytes) {
689: 		    nbytes, &rdata->data)) != 0) {
690: 			rdata->ulen = 0;
691: 			rdata->data = NULL;
694: 		rdata->ulen = nbytes;
701: 	memset(rdata->data,
714: 		p = (u_int8_t *)rdata->data + dbt->doff;
736: 		    &rdata->data, &rdata->ulen)) != 0)
741: 		p = (u_int8_t *)rdata->data + dbt->doff;
762: 		memcpy(rdata->data,
765: 		p = (u_int8_t *)rdata->data + dbt->doff;
784: 	rdata->size = F_ISSET(dbp, DB_AM_FIXEDLEN) ? t->re_len : tlen;
785: 	rdata->dlen = 0;
786: 	rdata->doff = 0;
787: 	rdata->flags = 0;
834: 		min = data->size < len ? data->size : len;
836: 		    p = dp, t = data->data;
843: 		    t = (u_int8_t *)data->data + data->size - 1;
850: 		repl.data = (u_int8_t *)data->data + prefix;
851: 		repl.size = data->size - (prefix + suffix);
902: 			ln = (db_indx_t)BINTERNAL_SIZE(data->size);
907: 		ln = (db_indx_t)BKEYDATA_SIZE(data->size);
940: 		if (data != NULL && data->size != 0)
941: 			memcpy(bi->data, data->data, data->size);
944: 		bk->len = data->size;
946: 		memcpy(bk->data, data->data, bk->len);
# /home/ystatter/virunga/bdb/db-6.0.30/src/btree/bt_cursor.c
1201: 	dbuf = data->data;
1205: 	space = data->ulen;
1209: 	endp = (int32_t *)((u_int8_t *)dbuf + data->ulen);
1269: 			if (space > data->ulen)
1306: 							data->size = (u_int32_t)
1356: 		if (space > data->ulen)
1467: 						data->size = (u_int32_t)
1469: 						    data->ulen - space, 1024);
1525: 		data->size = (data->ulen - space) + size;
2427: 	    &recno, sizeof(recno), &dbc->rdata->data, &dbc->rdata->ulen);
# /home/ystatter/virunga/bdb/db-6.0.30/src/btree/bt_verify.c
62: 	if ((ret = __db_vrfy_meta(dbp, vdp, &meta->dbmeta, pgno, flags)) != 0) {
72: 	ovflsize = meta->minkey > 0 ?
73: 	    B_MINKEY_TO_OVFLSIZE(dbp, meta->minkey, dbp->pgsize) : 0;
75: 	if (meta->minkey < 2 ||
81: 		    "%lu %lu"), (u_long)pgno, (u_long)meta->minkey));
83: 		pip->bt_minkey = meta->minkey;
86: 	pip->re_pad = meta->re_pad;
87: 	pip->re_len = meta->re_len;
95: 	if (meta->root == PGNO_INVALID ||
96: 	    meta->root == pgno || !IS_VALID_PGNO(meta->root) ||
97: 	    (pgno == PGNO_BASE_MD && meta->root != 1)) {
101: 		    "%lu %lu"), (u_long)pgno, (u_long)meta->root));
103: 		pip->root = meta->root;
106: 	if (F_ISSET(&meta->dbmeta, BTM_RENUMBER))
109: 	if (F_ISSET(&meta->dbmeta, BTM_SUBDB)) {
114: 		if (F_ISSET(&meta->dbmeta, BTM_DUP) && pgno == PGNO_BASE_MD) {
123: 	if (F_ISSET(&meta->dbmeta, BTM_DUP))
125: 	if (F_ISSET(&meta->dbmeta, BTM_DUPSORT))
127: 	if (F_ISSET(&meta->dbmeta, BTM_RECNUM))
136: 	if (F_ISSET(&meta->dbmeta, BTM_RECNO)) {
147: 	if (F_ISSET(&meta->dbmeta, BTM_COMPRESS)) {
194: 	if (F_ISSET(&meta->dbmeta, BTM_FIXEDLEN))
2858: 	for (current = btmeta->root;;) {
# /home/ystatter/virunga/bdb/db-6.0.30/src/btree/bt_rec.c
1516:  *	Recovery function for setting the root page on the meta-data page.
1558: 		meta->root = argp->root_pgno;
1559: 		meta->dbmeta.lsn = *lsnp;
1560: 		((BTREE *)file_dbp->bt_internal)->bt_root = meta->root;
1564: 		meta->dbmeta.lsn = argp->meta_lsn;
# /home/ystatter/virunga/bdb/db-6.0.30/src/btree/bt_open.c
370: 	if (meta->dbmeta.magic == DB_BTREEMAGIC) {
371: 		t->bt_minkey = meta->minkey;
372: 		t->re_pad = (int)meta->re_pad;
373: 		t->re_len = meta->re_len;
376: 		t->bt_root = meta->root;
381: 		    __memp_set_last_pgno(mpf, meta->dbmeta.last_pgno)) != 0)
414:  * Initialize a btree meta-data page.  The following fields may need
434: 	meta->dbmeta.lsn = *lsnp;
435: 	meta->dbmeta.pgno = pgno;
436: 	meta->dbmeta.magic = DB_BTREEMAGIC;
437: 	meta->dbmeta.version = DB_BTREEVERSION;
438: 	meta->dbmeta.pagesize = dbp->pgsize;
440: 		FLD_SET(meta->dbmeta.metaflags, DBMETA_CHKSUM);
442: 		meta->dbmeta.encrypt_alg = env->crypto_handle->alg;
443: 		DB_ASSERT(env, meta->dbmeta.encrypt_alg != 0);
444: 		meta->crypto_magic = meta->dbmeta.magic;
446: 	meta->dbmeta.type = P_BTREEMETA;
447: 	meta->dbmeta.free = PGNO_INVALID;
448: 	meta->dbmeta.last_pgno = pgno;
450: 		F_SET(&meta->dbmeta, BTM_DUP);
452: 		F_SET(&meta->dbmeta, BTM_FIXEDLEN);
454: 		F_SET(&meta->dbmeta, BTM_RECNUM);
456: 		F_SET(&meta->dbmeta, BTM_RENUMBER);
458: 		F_SET(&meta->dbmeta, BTM_SUBDB);
460: 		F_SET(&meta->dbmeta, BTM_DUPSORT);
463: 		F_SET(&meta->dbmeta, BTM_COMPRESS);
466: 		F_SET(&meta->dbmeta, BTM_RECNO);
467: 	memcpy(meta->dbmeta.uid, dbp->fileid, DB_FILE_ID_LEN);
469: 	meta->minkey = t->bt_minkey;
470: 	meta->re_len = t->re_len;
471: 	meta->re_pad = (u_int32_t)t->re_pad;
472: 	meta->blob_threshold = dbp->blob_threshold;
478: 		meta->dbmeta.nparts = part->nparts;
480: 			FLD_SET(meta->dbmeta.metaflags, DBMETA_PART_CALLBACK);
482: 			FLD_SET(meta->dbmeta.metaflags, DBMETA_PART_RANGE);
526: 		/* Build the meta-data page. */
533: 		meta->root = 1;
534: 		meta->dbmeta.last_pgno = 1;
561: 		/* Build the meta-data page. */
579: 		meta->root = 1;
580: 		meta->dbmeta.last_pgno = 1;
670: 	/* Build meta-data page. */
671: 	lsn = meta->dbmeta.lsn;
674: 	    txn, &meta->dbmeta.lsn, dbp->meta_pgno, (PAGE *)meta)) != 0)
688: 	    (ret = __bam_root_log(mdbp, txn, &meta->dbmeta.lsn, 0,
689: 	    meta->dbmeta.pgno, root->pgno, &meta->dbmeta.lsn)) != 0)
692: 	meta->root = root->pgno;
# /home/ystatter/virunga/bdb/db-6.0.30/src/btree/bt_compact.c
211: 	check_trunc = c_data->compact_truncate != PGNO_INVALID;
219: 	pgs_free = c_data->compact_pages_free;
256: 		c_data->compact_pages_examine++;
268: 		     (check_trunc && PGNO(pg) > c_data->compact_truncate))
337: 		    (!check_trunc || PGNO(pg) <= c_data->compact_truncate ||
344: 			c_data->compact_pages_examine++;
366: 	if (!LOCK_ISSET(metalock) && pgs_free == c_data->compact_pages_free &&
449: 				c_data->compact_pages_free++;
551: 		if (check_trunc && PGNO(pg) > c_data->compact_truncate) {
711: 			    PGNO(pg) > c_data->compact_truncate) {
772: 	     P_FREESPACE(dbp, pg) > factor && c_data->compact_pages != 0) {
834: 		    PGNO(pg) > c_data->compact_truncate) {
854: 		c_data->compact_pages_examine++;
943: 	if (npgno == PGNO_INVALID || c_data->compact_pages  == 0)
1125: 	if (c_data->compact_truncate != PGNO_INVALID &&
1126: 	     PGNO(ncp->csp->page) > c_data->compact_truncate) {
1519: 	c_data->compact_pages_free++;
1520: 	c_data->compact_pages--;
1536: 			c_data->compact_levels++;
1537: 			c_data->compact_pages_free++;
1539: 			if (c_data->compact_pages != 0)
1540: 				c_data->compact_pages--;
1867: 		c_data->compact_pages_free++;
1883: 				c_data->compact_levels++;
1884: 				c_data->compact_pages_free++;
1886: 				if (c_data->compact_pages != 0)
1887: 					c_data->compact_pages--;
1894: 		    c_data->compact_truncate != PGNO_INVALID &&
1895: 		    PGNO(npg) > c_data->compact_truncate &&
1901: 		if (c_data->compact_truncate != PGNO_INVALID &&
1902: 		     PGNO(pg) > c_data->compact_truncate && cp->csp != cp->sp) {
1957: 		c_data->compact_pages_examine++;
1958: 		if (bo->pgno > c_data->compact_truncate) {
2162: 		if (bo->pgno > c_data->compact_truncate && (ret =
2502: 		c_data->compact_pages_examine++;
2510: 		    pgno <= c_data->compact_truncate, &start)) != 0) {
2522: 		if (pgno <= c_data->compact_truncate)
2540: 		if (pgno > c_data->compact_truncate) {
2586: 	    (bt->bt_root > c_data->compact_truncate ||
2587: 	    bt->bt_meta > c_data->compact_truncate)) {
2621: 		if (PGNO(meta) > c_data->compact_truncate) {
2629: 		if (bt->bt_root > c_data->compact_truncate) {
2637: 			c_data->compact_pages_examine++;
2658: 			bt->bt_root = meta->root = PGNO(root);
# /home/ystatter/virunga/bdb/db-6.0.30/src/btree/bt_split.c
376: 	 * acquired during the get-a-new-page process because metadata page
# /home/ystatter/virunga/bdb/db-6.0.30/src/hash/hash_page.c
1830: 	    c_data == NULL ? 0 : c_data->compact_truncate != PGNO_INVALID;
1894: 				    c_data->compact_pages_free > 0)
1895: 					c_data->compact_pages_free--;
1992: 			c_data->compact_pages_free++;
2018: 	if (check_trunc && from_pgno > c_data->compact_truncate)
2037: 		if (check_trunc && from_pgno > c_data->compact_truncate)
# /home/ystatter/virunga/bdb/db-6.0.30/src/hash/hash_open.c
105: 	if (dbmeta->magic == DB_HASHMAGIC) {
108: 			hashp->h_hash = dbmeta->version < 5
120: 		    __memp_set_last_pgno(dbp->mpf, dbmeta->last_pgno)) != 0)
269:  * Initialize a hash meta-data page.  We assume that the meta-data page is
305: 	meta->dbmeta.lsn = *lsnp;
306: 	meta->dbmeta.pgno = pgno;
307: 	meta->dbmeta.magic = DB_HASHMAGIC;
308: 	meta->dbmeta.version = DB_HASHVERSION;
309: 	meta->dbmeta.pagesize = dbp->pgsize;
311: 		FLD_SET(meta->dbmeta.metaflags, DBMETA_CHKSUM);
313: 		meta->dbmeta.encrypt_alg = env->crypto_handle->alg;
314: 		DB_ASSERT(env, meta->dbmeta.encrypt_alg != 0);
315: 		meta->crypto_magic = meta->dbmeta.magic;
317: 	meta->dbmeta.type = P_HASHMETA;
318: 	meta->dbmeta.free = PGNO_INVALID;
319: 	meta->dbmeta.last_pgno = pgno;
320: 	meta->max_bucket = nbuckets - 1;
321: 	meta->high_mask = nbuckets - 1;
322: 	meta->low_mask = (nbuckets >> 1) - 1;
323: 	meta->ffactor = hashp->h_ffactor;
324: 	meta->nelem = hashp->h_nelem;
325: 	meta->h_charkey = hashp->h_hash(dbp, CHARKEY, sizeof(CHARKEY));
326: 	memcpy(meta->dbmeta.uid, dbp->fileid, DB_FILE_ID_LEN);
327: 	meta->blob_threshold = dbp->blob_threshold;
332: 		F_SET(&meta->dbmeta, DB_HASH_DUP);
334: 		F_SET(&meta->dbmeta, DB_HASH_SUBDB);
336: 		F_SET(&meta->dbmeta, DB_HASH_DUPSORT);
340: 		meta->dbmeta.nparts = part->nparts;
342: 			FLD_SET(meta->dbmeta.metaflags, DBMETA_PART_CALLBACK);
344: 			FLD_SET(meta->dbmeta.metaflags, DBMETA_PART_RANGE);
351: 	 * meta-data header (spares[0]).
353: 	meta->spares[0] = pgno + 1;
357: 		meta->spares[i] = meta->spares[0];
359: 		meta->spares[i] = PGNO_INVALID;
407: 		/* Build meta-data page. */
414: 		meta->dbmeta.last_pgno = lpgno;
416: 		    txn, &lsn, meta->dbmeta.pgno, (PAGE *)meta)) != 0)
440: 		/* Build meta-data page. */
458: 		meta->dbmeta.last_pgno = lpgno;
549: 	/* Initialize the new meta-data page. */
550: 	lsn = meta->dbmeta.lsn;
555: 	 * worth).  We need to get the master meta-data page to figure
567: 	 * Now update the hash meta-data page to reflect where the first
570: 	meta->spares[0] = mmeta->last_pgno + 1;
571: 	for (i = 0; i < NCACHED && meta->spares[i] != PGNO_INVALID; i++)
572: 		meta->spares[i] = meta->spares[0];
576: 	    txn, &meta->dbmeta.lsn, dbp->meta_pgno, (PAGE *)meta)) != 0)
586: 		    &LSN(mmeta), 0, &LSN(mmeta), meta->spares[0],
587: 		    meta->max_bucket + 1, 0, mmeta->last_pgno)) != 0)
590: 	/* Release the new meta-data page. */
595: 	lpgno += mmeta->last_pgno;
604: 	mmeta->last_pgno = lpgno;
# /home/ystatter/virunga/bdb/db-6.0.30/src/hash/hash_meta.c
19:  * Acquire the meta-data page.
72:  * Release the meta-data page.
100:  * Mark the meta-data page dirty.
# /home/ystatter/virunga/bdb/db-6.0.30/src/hash/hash.c
679: 	dbuf = data->data;
683: 	space = data->ulen;
687: 	endp = (int32_t *) ((u_int8_t *)dbuf + data->ulen);
728: 							data->size = (u_int32_t)
841: 						data->size = (u_int32_t)
843: 						    data->ulen - space, 1024);
910: 				if (space > data->ulen) {
944: 			if (space > data->ulen)
949: 				if (space > data->ulen)
972: 			if (space > data->ulen)
997: 			if (space > data->ulen)
1129: 		if (dbp->blob_threshold && (data->size >=
1132: 		else if (ISBIG(hcp, data->size))
1135: 			nbytes += HKEYDATA_PSIZE(data->size);
1149: 			if (F_ISSET(data, DB_DBT_PARTIAL) && data->doff != 0) {
1158: 				    data->size + data->doff,
1163: 				memset(tmp_val.data, 0, data->doff);
1165: 				    data->doff, data->data, data->size);
1333: 	mpgno = mmeta->pgno;
1342: 	 * too late then because we've logged the meta-data split.  What
1370: 		/* Get the master meta-data page to do allocation. */
1381: 		pgno = mmeta->last_pgno + 1;
1386: 	/* Log the meta-data split first. */
1396: 		    &lsn, 0, hcp->hdr->max_bucket, mpgno, &mmeta->lsn,
1398: 		    pgno, &lsn, newalloc, mmeta->last_pgno)) != 0)
1424: 		mmeta->last_pgno = pgno;
1425: 		mmeta->lsn = lsn;
1438: 	 * Update the meta-data page of this hash database.
1680: 	    &dbc->rdata->data, &dbc->rdata->ulen)) != 0) {
# /home/ystatter/virunga/bdb/db-6.0.30/src/hash/hash_rec.c
973: 	/* Now we have to update the meta-data page. */
1020: 	 * in the master meta-data page (which may or may not be the
1030: 		cmp_n = LOG_COMPARE(lsnp, &mmeta->lsn);
1031: 		cmp_p = LOG_COMPARE(&mmeta->lsn, &argp->mmetalsn);
1034: 			mmeta->lsn = *lsnp;
1037: 			mmeta->lsn = argp->mmetalsn;
1045: 		mmeta->last_pgno = argp->last_pgno;
1046: 	else if (cmp_p == 0 && DB_REDO(op) && mmeta->last_pgno < pgno)
1047: 		mmeta->last_pgno = pgno;
1097: 	cmp_n = LOG_COMPARE(lsnp, &meta->dbmeta.lsn);
1098: 	cmp_p = LOG_COMPARE(&meta->dbmeta.lsn, &argp->meta_lsn);
1099: 	CHECK_LSN(env, op, cmp_p, &meta->dbmeta.lsn, &argp->meta_lsn);
1103: 		meta->max_bucket = argp->bucket - 1;
1104: 		if (argp->bucket == meta->low_mask + 1) {
1105: 			meta->spares[
1107: 			meta->high_mask = meta->low_mask;
1108: 			meta->low_mask >>= 1;
1110: 		meta->dbmeta.lsn = *lsnp;
1114: 		meta->max_bucket = argp->bucket;
1115: 		if (argp->bucket == meta->high_mask + 1) {
1116: 			meta->spares[__db_log2(argp->bucket) + 1] =
1118: 			meta->low_mask = meta->high_mask;
1119: 			meta->high_mask = meta->max_bucket | meta->low_mask;
1121: 		meta->dbmeta.lsn = argp->meta_lsn;
1226: 			mmeta->last_pgno = argp->last_pgno;
1238: 	if (pgno > mmeta->last_pgno) {
1240: 		mmeta->last_pgno = pgno;
1257:  * using the MPOOL_NEW_GROUP flag.  We then log the meta-data page with a
1349: 		meta->spares[argp->slot] = argp->new - bucket;
1354: 		meta->spares[argp->slot] = argp->old - bucket;
1668: 	/* Now we have to update the meta-data page. */
1713: 	 * in the master meta-data page (which may or may not be the
1723: 		cmp_n = LOG_COMPARE(lsnp, &mmeta->lsn);
1724: 		cmp_p = LOG_COMPARE(&mmeta->lsn, &argp->mmetalsn);
1727: 			mmeta->lsn = *lsnp;
1730: 			mmeta->lsn = argp->mmetalsn;
1737: 	if (mmeta->last_pgno < pgno)
1738: 		mmeta->last_pgno = pgno;
1829: 	if (pgno > mmeta->last_pgno) {
1831: 		mmeta->last_pgno = pgno;
1848:  * using the MPOOL_NEW_GROUP flag.  We then log the meta-data page with a
# /home/ystatter/virunga/bdb/db-6.0.30/src/hash/hash_verify.c
1212: 	for (bucket = 0; bucket <= hmeta->max_bucket; bucket++) {
1213: 		pgno = BS_TO_PAGE(bucket, hmeta->spares);
# /home/ystatter/virunga/bdb/db-6.0.30/src/hash/hash_upgrade.c
47: 	newmeta.dbmeta.lsn = oldmeta->lsn;
48: 	newmeta.dbmeta.pgno = oldmeta->pgno;
49: 	newmeta.dbmeta.magic = oldmeta->magic;
51: 	newmeta.dbmeta.pagesize = oldmeta->pagesize;
55: 	newmeta.dbmeta.flags = oldmeta->flags;
58: 	newmeta.dbmeta.free = oldmeta->last_freed;
61: 	newmeta.max_bucket = oldmeta->max_bucket;
62: 	newmeta.high_mask = oldmeta->high_mask;
63: 	newmeta.low_mask = oldmeta->low_mask;
64: 	newmeta.ffactor = oldmeta->ffactor;
65: 	newmeta.nelem = oldmeta->nelem;
66: 	newmeta.h_charkey = oldmeta->h_charkey;
89: 	o_spares = oldmeta->spares;
132: 	pagesize = meta->dbmeta.pagesize;
146: 	last_desired = BS_TO_PAGE(meta->high_mask, meta->spares);
193: 	memmove(newmeta->spares, oldmeta->spares, sizeof(oldmeta->spares));
194: 	newmeta->h_charkey = oldmeta->h_charkey;
195: 	newmeta->nelem = oldmeta->nelem;
196: 	newmeta->ffactor = oldmeta->ffactor;
197: 	newmeta->low_mask = oldmeta->low_mask;
198: 	newmeta->high_mask = oldmeta->high_mask;
199: 	newmeta->max_bucket = oldmeta->max_bucket;
200: 	memmove(newmeta->dbmeta.uid,
201: 	    oldmeta->dbmeta.uid, sizeof(oldmeta->dbmeta.uid));
202: 	newmeta->dbmeta.flags = oldmeta->dbmeta.flags;
203: 	newmeta->dbmeta.record_count = 0;
204: 	newmeta->dbmeta.key_count = 0;
205: 	ZERO_LSN(newmeta->dbmeta.unused3);
208: 	newmeta->dbmeta.version = 7;
212: 		F_SET(&newmeta->dbmeta, DB_HASH_DUPSORT);
286: 	newmeta->dbmeta.version = 9;
328:  * __ham_60_hashmeta--
351: 	hmeta->dbmeta.version = 10;
# /home/ystatter/virunga/bdb/db-6.0.30/src/hash/hash_compact.c
49: 	check_trunc = c_data->compact_truncate != PGNO_INVALID;
81: 			c_data->compact_pages_examine++;
88: 		c_data->compact_pages_examine++;
108: 			    pgno > c_data->compact_truncate) {
109: 				c_data->compact_pages_examine++;
130: 					c_data->compact_pages--;
205: 	c_data->compact_empty_buckets += empty_buckets;
233: 	check_trunc = c_data->compact_truncate != PGNO_INVALID;
250: 		    PGNO(pg) > c_data->compact_truncate &&
319: 		c_data->compact_pages_examine++;
353: 			c_data->compact_pages_examine++;
354: 			c_data->compact_pages_free++;
399: 	if (pgno > c_data->compact_truncate) {
400: 		c_data->compact_pages_examine++;
412: 			c_data->compact_pages--;
468: 	for (i = 0; i < NCACHED && meta->spares[i] != PGNO_INVALID; i++) {
476: 		start_pgno = meta->spares[i] + bucket;
527: 			c_data->compact_pages_examine++;
529: 		meta->spares[i] = free_pgno - (size + bucket);
532: 	    PGNO(hcp->hdr) > c_data->compact_truncate)
# /home/ystatter/virunga/bdb/db-6.0.30/src/hash/hash_stat.c
61: 	 * Don't take the page number from the meta-data page -- that value is
# /home/ystatter/virunga/bdb/db-6.0.30/src/sequence/sequence.c
607: 		data->data = NULL;
608: 		data->flags = DB_DBT_REALLOC;
615: 			data->flags = DB_DBT_REALLOC;
616: 			data->data = NULL;
622: 	if (data->size < sizeof(seq->seq_record)) {
639: 		if (data->size <= seq->seq_data.size) {
640: 			memcpy(seq->seq_data.data, data->data, data->size);
641: 			__os_ufree(env, data->data);
643: 			seq->seq_data.data = data->data;
644: 			seq->seq_data.size = data->size;
723: 		if (data->data != NULL)
724: 			__os_ufree(env, data->data);
# /home/ystatter/virunga/bdb/db-6.0.30/src/dbinc/hash.h
71: 	HMETA *hdr;			/* Pointer to meta-data page. */
119: /* On page duplicates are stored as a string of size-data-size triples. */
# /home/ystatter/virunga/bdb/db-6.0.30/src/dbinc/repmgr.h
760:  * Flags for application-message meta-data.
# /home/ystatter/virunga/bdb/db-6.0.30/src/dbinc/txn.h
186:  *	Meta-data uniquely describing a transaction commit across a replication
# /home/ystatter/virunga/bdb/db-6.0.30/src/dbinc/qam.h
55: 	db_pgno_t q_meta;		/* Database meta-data page. */
# /home/ystatter/virunga/bdb/db-6.0.30/src/dbinc/crypto.h
32:  * We store the algorithm in an 8-bit field on the meta-page.  So we
# /home/ystatter/virunga/bdb/db-6.0.30/src/dbinc/db_upgrade.h
41: 	DBMETA31  dbmeta;		/* 00-71: Generic meta-data header. */
58: 	DBMETA31 dbmeta;	/* 00-71: Generic meta-data page header. */
80: 	DBMETA31 dbmeta;	/* 00-71: Generic meta-data header. */
95: 	DBMETA31 dbmeta;	/* 00-71: Generic meta-data header. */
130: 	DBMETA30	dbmeta;	/* 00-55: Generic meta-data header. */
147: 	DBMETA30 dbmeta;	/* 00-55: Generic meta-data page header. */
172: 	DBMETA30    dbmeta;	/* 00-55: Generic meta-data header. */
# /home/ystatter/virunga/bdb/db-6.0.30/src/dbinc/btree.h
468: 	db_pgno_t bt_meta;		/* Database meta-data page. */
# /home/ystatter/virunga/bdb/db-6.0.30/src/dbinc/db_page.h
60:  * headers and cover enough of the btree and hash meta-data pages to obliterate
84: 	u_int8_t  metaflags;	/* 26: Meta-only flags */
110: 	DBMETA	dbmeta;		/* 00-71: Generic meta-data header. */
141: 	DBMETA dbmeta;		/* 00-71: Generic meta-data page header. */
177: 	DBMETA    dbmeta;		/* 00-71: Generic meta-data header. */
207: 	DBMETA    dbmeta;	/* 00-71: Generic meta-data header. */
539:  * is to store the number of records in the meta-data page, which will create
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_am.c
480: 		 * data->data may be replaced and then freed.  To avoid
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_meta.c
66:  * a meta-data page (used instead of P_INIT).  We need to make sure that we
80: 	save_lsn = meta->lsn;
82: 	meta->lsn = save_lsn;
83: 	meta->pagesize = dbp->pgsize;
85: 		FLD_SET(meta->metaflags, DBMETA_CHKSUM);
86: 	meta->pgno = pgno;
87: 	meta->type = (u_int8_t)pgtype;
144: 	last = meta->last_pgno;
145: 	if (meta->free == PGNO_INVALID) {
150: 		last = pgno = meta->last_pgno + 1;
154: 		pgno = meta->free;
171: 		 * then set meta->free to the that page's next_pgno, but
199: 		    pgno, (u_int32_t)type, newnext, meta->last_pgno)) != 0)
204: 	meta->free = newnext;
214: 		meta->last_pgno = pgno;
365: 	last_pgno = meta->last_pgno;
366: 	next_pgno = meta->free;
413: 		last_pgno = meta->last_pgno;
504: 		meta->last_pgno--;
529: 		DB_ASSERT(dbp->env, meta->pgno == PGNO_BASE_MD);
530: 		meta->last_pgno--;
565: 			meta->free = h->pgno;
819: 			c_data->compact_pages_truncated += *last_pgno - pgno;
891: 		*last_pgnop = meta->last_pgno;
892: 	if ((pgno = meta->free) == PGNO_INVALID)
931: 	    &nelems, meta->free, &meta->last_pgno, &LSN(meta), 0)) != 0)
935: 		meta->free = PGNO_INVALID;
937: 		meta->free = list[0].pgno;
940: 		*last_pgnop = meta->last_pgno;
953: 		c_data->compact_truncate = (u_int32_t)meta->last_pgno - nelems;
954: 		if (c_data->compact_truncate > nelems >> 2)
955: 			c_data->compact_truncate -= nelems >> 2;
1031: 		lpgno = meta->last_pgno;
1078: 	meta->last_pgno = list[start] - 1;
1081: 		meta->free = PGNO_INVALID;
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_pr.c
329: 	 * by reading the value from the meta-data page, that's going to be
436: 	__db_msg(env, "\tmagic: %#lx", (u_long)dbmeta->magic);
437: 	__db_msg(env, "\tversion: %lu", (u_long)dbmeta->version);
438: 	__db_msg(env, "\tpagesize: %lu", (u_long)dbmeta->pagesize);
439: 	__db_msg(env, "\ttype: %lu", (u_long)dbmeta->type);
440: 	__db_msg(env, "\tmetaflags %#lx", (u_long)dbmeta->metaflags);
442: 	    (u_long)dbmeta->key_count, (u_long)dbmeta->record_count);
443: 	if (dbmeta->nparts)
444: 		__db_msg(env, "\tnparts: %lu", (u_long)dbmeta->nparts);
453: 		    env, &mb, "\tfree list: %lu", (u_long)dbmeta->free);
454: 		for (pgno = dbmeta->free,
475: 		__db_msg(env, "\tlast_pgno: %lu", (u_long)dbmeta->last_pgno);
480: 		__db_msgadd(env, &mb, "\tflags: %#lx", (u_long)dbmeta->flags);
481: 		__db_prflags(env, &mb, dbmeta->flags, fn, " (", ")");
486: 	for (p = (u_int8_t *)dbmeta->uid,
497:  *	Print out the btree meta-data page.
536:  *	Print out the hash meta-data page.
584:  *	Print out the queue meta-data page.
608:  *	Print out the heap meta-data page.
772: 	case P_QAMDATA:				/* Should be meta->start. */
1497: 			data->size = (u_int32_t)DB_ALIGN(data->size, 1024);
1499: 			    dbc->env, data->size, &data->data)) != 0)
1501: 			data->ulen = data->size;
1506: 	if (data->ulen < MEGABYTE) {
1507: 		if ((data->data = realloc(
1508: 		    data->data, data->ulen = MEGABYTE)) == NULL) {
1566: 		    dbp->env, fhp, data, offset, data->ulen)) != 0)
1572: 		skip_newline = data->size < left ? 1 : 0;
1576: 		if (data->size > left)
1579: 			left = left - data->size;
1580: 		offset = offset + data->size;
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_sort_multiple.c
68: 		(ad).data = (u_int8_t*)data->data + (adptr)[0];		\
305: 			dstart = (u_int32_t*)((u_int8_t *)data->data +
306: 				data->ulen) - 1;
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_dup.c
137: 		bk.len = data == NULL ? 0 : data->size;
156: 		memcpy(p + hdr->size, data->data, data->size);
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_compact.c
40: 		c_data->compact_pages_free =				\
42: 		c_data->compact_levels = save_data.compact_levels;	\
43: 		c_data->compact_truncate = save_data.compact_truncate;	\
44: 		c_data->compact_empty_buckets =				\
107: 	empty_buckets = c_data->compact_empty_buckets;
154: 	truncated = c_data->compact_pages_truncated;
168: 	if (c_data->compact_fillpercent != 0) {
169: 		factor *= c_data->compact_fillpercent;
175: 	if (c_data->compact_pages == 0)
176: 		c_data->compact_pages = DB_MAX_PAGES;
190: 			if (c_data->compact_timeout != 0 &&
192: 			    c_data->compact_timeout, DB_SET_LOCK_TIMEOUT)) != 0)
214: 			c_data->compact_deadlock++;
273: 			isdone = meta->free == PGNO_INVALID;
279: 			c_data->compact_empty_buckets -= empty_buckets;
280: 			if (!isdone || c_data->compact_empty_buckets != 0)
283: 			c_data->compact_empty_buckets += empty_buckets;
296: 			c_data->compact_pages_truncated =
297: 			    truncated + last_pgno - meta->last_pgno;
637: 		if (pgno <= c_data->compact_truncate)
873: 		meta->free = next_free;
1045: 	c_data->compact_pages_examine++;
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db.c
140: 	 * read the meta-page, so we do not check those here.  However, if
141: 	 * the meta-page caused checksumming to be turned on and it wasn't
248: 		 * We're handling actual data, not on-page meta-data,
368: 		 * We're handling actual data, not on-page meta-data, so it
668: 		 * file type until after we open it and read the meta-data
1315:  *	Log a meta-data or root page during a subdatabase create operation.
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_join.c
805: 		 * We don't want to step on data->data;  use a new
821: 			    ldata.size, &data->data, &data->size)) != 0)
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_method.c
484: 	 * subdatabases flag set, and the meta-data page has the right value,
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_upg.c
180: 			 * single meta-data page by hand.
193: 			 * the meta-data page.
217: 			if (FLD_ISSET(meta->metaflags, DBMETA_CHKSUM))
219: 			if (meta->encrypt_alg != 0) {
229: 			    &meta->pagesize, sizeof(u_int32_t));
250: 			 * single meta-data page by hand.
282: 			 * the meta-data page.
308: 			 * the meta-data page.
310: 			memcpy(&dbp->pgsize, &meta->pagesize,
320: 			memcpy(&tmpflags, &meta->metaflags, sizeof(u_int8_t));
323: 			memcpy(&tmpflags, &meta->encrypt_alg, sizeof(u_int8_t));
368: 			    &meta->pagesize, sizeof(u_int32_t));
373: 			if (FLD_ISSET(meta->metaflags, DBMETA_CHKSUM))
375: 			if (meta->encrypt_alg != 0) {
408: 			    &meta->pagesize, sizeof(u_int32_t));
413: 			if (FLD_ISSET(meta->metaflags, DBMETA_CHKSUM))
415: 			if (meta->encrypt_alg != 0) {
444: 			 * needs upgrading is the meta-database page, don't
612:  *	Update the meta->last_pgno field.
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_cam.c
1384: 				orig_ulen = data->ulen;
1385: 				data->ulen = 0;
1436: 		data->size = data->ulen;
1451: 		    data, &dbc->rdata->data, &dbc->rdata->ulen);
1479: 		data->ulen = orig_ulen;
1570: 	 * If there is an append callback, the value stored in data->data may
1729: 	size = data->size;
1735: 		 * If we're not doing a partial put, copy data->data into
1736: 		 * out_data->data, then pad out out_data->data. This overrides
1745: 			    env, re_len, &out_data->data)) != 0)
1750: 			* to pad from the end of out_data, not from data->size.
1752: 		       size = out_data->size;
1755: 			    env, re_len, &out_data->data)) != 0)
1757: 			memcpy(out_data->data, data->data, size);
1759: 		memset((u_int8_t *)out_data->data + size, re_pad,
1761: 		out_data->size = re_len;
2278: 	if (newdata.data != NULL && newdata.data != data->data)
3139: 		    sizeof(oob), &sdbc->rdata->data, &sdbc->rdata->ulen));
3792: 	if (nbytes < data->doff + data->dlen)		/* Case 1 */
3793: 		return (data->doff + data->size);
3795: 	return (nbytes + data->size - data->dlen);	/* Case 2 */
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_conv.c
96: 		 * If checksumming is set on the meta-page, we must set
446:  *	Byteswap the common part of the meta-data page.
458: 	/* Swap the meta-data information. */
812: 		pgsize = hoffset + pdata->size;
817: 		memcpy((u_int8_t *)pgcopy + hoffset, pdata->data, pdata->size);
830: 			    __os_malloc(env, pdata->size, &pdata->data)) != 0) {
836: 		memcpy(pdata->data, (u_int8_t *)pgcopy + hoffset, pdata->size);
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_vrfy.c
576: 	if (meta->pgno != PGNO_BASE_MD) {
580: 		    (u_long)PGNO_BASE_MD, (u_long)meta->pgno));
584: 	if (__db_is_valid_magicno(meta->magic, &dbp->type))
587: 		M_32_SWAP(meta->magic);
588: 		if (__db_is_valid_magicno(meta->magic,
595: 			    (u_long)PGNO_BASE_MD, (u_long)meta->magic));
604: 		M_32_SWAP(meta->version);
606: 	    (meta->version > DB_BTREEVERSION ||
607: 	    meta->version < DB_BTREEOLDVER)) ||
609: 	    (meta->version > DB_HASHVERSION ||
610: 	    meta->version < DB_HASHOLDVER)) ||
612: 	    (meta->version > DB_HEAPVERSION ||
613: 	    meta->version < DB_HEAPOLDVER)) ||
615: 	    (meta->version > DB_QAMVERSION ||
616: 	    meta->version < DB_QAMOLDVER))) {
620: 		    "%lu %lu"), (u_long)PGNO_BASE_MD, (u_long)meta->version));
628: 		M_32_SWAP(meta->pagesize);
629: 	if (IS_VALID_PAGESIZE(meta->pagesize))
630: 		dbp->pgsize = meta->pagesize;
634: 		    "%lu %lu"), (u_long)PGNO_BASE_MD, (u_long)meta->pagesize));
650: 	if ((dbp->type == DB_BTREE && meta->type != P_BTREEMETA) ||
651: 	    (dbp->type == DB_HASH && meta->type != P_HASHMETA) ||
652: 	    (dbp->type == DB_HEAP && meta->type != P_HEAPMETA) ||
653: 	    (dbp->type == DB_QUEUE && meta->type != P_QAMMETA)) {
656: 		    "%lu %lu"), (u_long)PGNO_BASE_MD, (u_long)meta->type));
660: 	 * 26: Meta-flags.
662: 	if (meta->metaflags != 0) {
663: 		if (FLD_ISSET(meta->metaflags,
667: 			    "Page %lu: bad meta-data flags value %#lx",
669: 			    (u_long)meta->metaflags));
671: 		if (FLD_ISSET(meta->metaflags, DBMETA_CHKSUM))
673: 		if (FLD_ISSET(meta->metaflags, DBMETA_PART_RANGE))
675: 		if (FLD_ISSET(meta->metaflags, DBMETA_PART_CALLBACK))
678: 		if (FLD_ISSET(meta->metaflags,
680: 		    (ret = __partition_init(dbp, meta->metaflags)) != 0)
691: 	    M_32_SWAP(meta->free);
692: 	freelist = meta->free;
694: 	    M_32_SWAP(meta->last_pgno);
695: 	vdp->meta_last_pgno = meta->last_pgno;
703: 	pip->type = meta->type;
717: 	memcpy(dbp->fileid, meta->uid, DB_FILE_ID_LEN);
1426: 	 * things we want to verify is that the data--as specified
1464: 	switch (meta->type) {
1483: 	if (!__db_is_valid_magicno(meta->magic, &magtype)) {
1497: 	    (meta->version > DB_BTREEVERSION ||
1498: 	    meta->version < DB_BTREEOLDVER)) ||
1500: 	    (meta->version > DB_HASHVERSION ||
1501: 	    meta->version < DB_HASHOLDVER)) ||
1503: 	    (meta->version > DB_HEAPVERSION ||
1504: 	    meta->version < DB_HEAPOLDVER)) ||
1506: 	    (meta->version > DB_QAMVERSION ||
1507: 	    meta->version < DB_QAMOLDVER))) {
1511: 		    "%lu %lu"), (u_long)pgno, (u_long)meta->version));
1515: 	if (meta->pagesize != dbp->pgsize) {
1518: 		    "%lu %lu"), (u_long)pgno, (u_long)meta->pagesize));
1522: 	if (meta->metaflags != 0) {
1523: 		if (FLD_ISSET(meta->metaflags,
1527: 			    "Page %lu: bad meta-data flags value %#lx",
1529: 			    (u_long)meta->metaflags));
1531: 		if (FLD_ISSET(meta->metaflags, DBMETA_CHKSUM))
1533: 		if (FLD_ISSET(meta->metaflags, DBMETA_PART_RANGE))
1535: 		if (FLD_ISSET(meta->metaflags, DBMETA_PART_CALLBACK))
1545: 	if (pgno != PGNO_BASE_MD && meta->free != PGNO_INVALID) {
1553: 	if (IS_VALID_PGNO(meta->free))
1554: 		pip->free = meta->free;
1559: 		    (u_long)pgno, (u_long)meta->free));
1573: 	    dbtype != DB_QUEUE && meta->last_pgno != vdp->last_pgno) {
1579: 		    (u_long)meta->last_pgno, (u_long)vdp->last_pgno));
1581: 		vdp->meta_last_pgno = meta->last_pgno;
1870: 		if (F_ISSET(&btmeta->dbmeta, BTM_RECNO)) {
1887: 			    F_ISSET(&btmeta->dbmeta, BTM_DUP), flags)) != 0)
1917: 			h_internal->h_hash = hmeta->dbmeta.version < 5
1919: 		if (hmeta->h_charkey !=
1935: 		for (bucket = 0; bucket <= hmeta->max_bucket; bucket++) {
1936: 			pgno = BS_TO_PAGE(bucket, hmeta->spares);
2778: 		if (bkdata->len != sizeof(db_pgno_t)) {
2783: 		    (db_pgno_t *)bkdata->data, sizeof(db_pgno_t));
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_rename.c
342: 	 * get the meta-data page number (via MU_OPEN) so that we can
343: 	 * read the meta-data page and obtain a handle lock.  Once we've
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_iface.c
947: 		if (data->ulen < 1024 ||
948: 		    data->ulen < dbp->pgsize || data->ulen % 1024 != 0) {
2548: 		if (data->ulen < 1024 ||
2549: 		    data->ulen < dbp->pgsize || data->ulen % 1024 != 0) {
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/partition.c
488: 	if (meta->magic != DB_HASHMAGIC &&
489: 	    (meta->magic != DB_BTREEMAGIC || F_ISSET(meta, BTM_RECNO))) {
495: 	if (!FLD_ISSET(meta->metaflags,
504: 	    FLD_ISSET(meta->metaflags, DBMETA_PART_CALLBACK)) ||
506: 	    FLD_ISSET(meta->metaflags, DBMETA_PART_RANGE))) {
513: 	if (FLD_ISSET(meta->metaflags, DBMETA_PART_CALLBACK) &&
530: 		if (LF_ISSET(DB_CREATE) && meta->nparts == 0) {
536: 			part->nparts = meta->nparts;
537: 	} else if (meta->nparts != 0 && part->nparts != meta->nparts) {
544: 	if (meta->magic == DB_HASHMAGIC) {
550: 	} else if (meta->magic != DB_BTREEMAGIC) {
556: 		pgsize = meta->pagesize;
600: 	return (ka->compare(ka->dbp, ka->key, kb->key, NULL));
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_open.c
42:  *    name will be non-NULL, subname will be NULL, and meta-pgno will be
45:  *    name will be non-NULL, subname may be NULL and meta-pgno will be
407: 		/* Subdb exists; read meta-data page and initialize. */
417: 		 * If __db_meta_setup found that the meta-page hadn't
450:  *	Validate a buffer containing a possible meta-data page. It is 
480: 	magic = meta->magic;
499: 		swap_lsn = meta->lsn;
509: 	if (FLD_ISSET(meta->metaflags, DBMETA_CHKSUM)) {
517: 			is_hmac = meta->encrypt_alg != 0;
540:  * Take a buffer containing a meta-data page and figure out if it's
541:  * valid, and if so, initialize the dbp from the meta-data page.
569: 	magic = meta->magic;
583: 		 * subdatabase had its meta-data page allocated, but
588: 		    meta->pgno != PGNO_INVALID))
623: 		flags = meta->flags;
671: 	if (FLD_ISSET(meta->metaflags,
673: 	    (ret = __partition_init(dbp, meta->metaflags)) != 0)
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_dispatch.c
144: 		 * 1. If this is a meta-record, one not associated with
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_rec.c
683: 		meta->free = argp->next;
684: 		if (argp->pgno > meta->last_pgno)
685: 			meta->last_pgno = argp->pgno;
695: 			meta->free = argp->pgno;
696: 		meta->last_pgno = argp->last_pgno;
814: 		if (meta->last_pgno <= argp->pgno && (ret = __memp_ftruncate(
893: 			meta->last_pgno = argp->pgno - 1;
897: 			meta->free = argp->pgno;
905: 			if (meta->last_pgno < argp->pgno)
906: 				meta->last_pgno = argp->pgno;
907: 			meta->free = argp->next;
926: 	if (DB_REDO(op) || (is_meta && meta->last_pgno < argp->pgno)) {
933: 			    DB_REDO(op) && meta->last_pgno <= argp->pgno)
970: 		if (is_meta && meta->last_pgno <= argp->pgno &&
1336: 					meta->free = PGNO_INVALID;
1338: 					meta->free = pglist->pgno;
1343: 			 * don't move the meta->last_pgno forward.
1345: 			if (meta->last_pgno > last_pgno)
1346: 				meta->last_pgno = last_pgno;
1394: 			if (meta->last_pgno < argp->last_pgno)
1395: 				meta->last_pgno = argp->last_pgno;
1397: 				meta->free = argp->next_free;
1639: 					meta->free = PGNO_INVALID;
1641: 					meta->free = pglist->pgno;
1643: 			meta->last_pgno = pgno;
1687: 			meta->last_pgno = argp->last_pgno;
1689: 				meta->free = pglist->pgno;
1782: 		meta->free = argp->next;
1783: 		if (argp->pgno > meta->last_pgno)
1784: 			meta->last_pgno = argp->pgno;
1946: 			meta->free = argp->pgno;
1952: 		 * original allocation which incremented meta->free.
1954: 		if (prevp == NULL && meta->last_pgno < meta->free)
1955: 			meta->last_pgno = meta->free;
1961: 			meta->free = argp->next;
1965: 		if (prevp == NULL && meta->last_pgno < argp->pgno)
1966: 			meta->last_pgno = argp->pgno;
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/db_setid.c
131: 	if (FLD_ISSET(meta->metaflags,
133: 	    __part_fileid_reset(env, ip, name, meta->nparts, encrypted)) != 0)
136: 	subdb = meta->type == P_BTREEMETA && F_ISSET(meta, BTM_SUBDB);
138: 	memcpy(meta->uid, fileid, DB_FILE_ID_LEN);
187: 		 * We're handling actual data, not on-page meta-data, so it
# /home/ystatter/virunga/bdb/db-6.0.30/src/db/crdel_rec.c
84: 		 * and this is the meta-data page, then we need to set up a
96: 		 * was logged separately. Then we wrote the meta-data onto
# /home/ystatter/virunga/bdb/db-6.0.30/src/qam/qam_rec.c
50: 	if (meta->page_ext == 0)
53: 		rec_ext = meta->page_ext * meta->rec_page;
55: 	if (meta->first_recno == RECNO_OOB)
56: 		meta->first_recno++;
57: 	while (meta->first_recno != meta->cur_recno &&
60: 		    &meta->first_recno, 0, &exact)) != 0)
69: 		    rec_ext != 0 && meta->first_recno % rec_ext == 0)
75: 		QAM_INC_RECNO(meta->first_recno);
125: 			meta->dbmeta.pgno = metapg;
126: 			meta->dbmeta.type = P_QAMMETA;
141: 			meta->first_recno = argp->recno;
219: 			meta->dbmeta.pgno = metapg;
220: 			meta->dbmeta.type = P_QAMMETA;
243: 			meta->first_recno = argp->old_first;
244: 			meta->cur_recno = argp->old_cur;
258: 		    meta->first_recno == argp->old_first) {
260: 				meta->first_recno = argp->new_first;
263: 				    &meta->first_recno, 0, &exact)) != 0)
266: 					meta->first_recno = argp->new_first;
275: 		    meta->cur_recno == argp->old_cur) {
277: 				meta->cur_recno = argp->new_cur;
280: 				     &meta->cur_recno, 0, &exact)) != 0)
283: 					meta->cur_recno = argp->new_cur;
291: 		meta->dbmeta.lsn = *lsnp;
367: 		if (meta->first_recno == RECNO_OOB ||
369: 		    (meta->first_recno <= meta->cur_recno ||
370: 		    meta->first_recno -
371: 		    argp->recno < argp->recno - meta->cur_recno))) {
373: 			meta->first_recno = argp->recno;
495: 		if (meta->first_recno == RECNO_OOB ||
497: 		    (meta->first_recno <= meta->cur_recno ||
498: 		    meta->first_recno -
499: 		    argp->recno < argp->recno - meta->cur_recno))) {
500: 			meta->first_recno = argp->recno;
608: 		/* Fix meta-data page. */
615: 			meta->first_recno = argp->recno;
617: 		if (argp->recno == meta->cur_recno ||
620: 			meta->cur_recno = argp->recno + 1;
# /home/ystatter/virunga/bdb/db-6.0.30/src/qam/qam_verify.c
68: 	if ((ret = __db_vrfy_meta(dbp, vdp, &meta->dbmeta, pgno, flags)) != 0) {
87: 	if (DB_ALIGN(meta->re_len + sizeof(QAMDATA) - 1, sizeof(u_int32_t)) *
88: 	    meta->rec_page + QPAGE_SZ(dbp) > dbp->pgsize) {
91: 		    "%lu %lu"), (u_long)pgno, (u_long)meta->re_len));
100: 		vdp->re_pad = meta->re_pad;
101: 		qp->re_pad = (int)meta->re_pad;
102: 		qp->re_len = vdp->re_len = meta->re_len;
103: 		qp->rec_page = vdp->rec_page = meta->rec_page;
104: 		qp->page_ext = vdp->page_ext = meta->page_ext;
127: 	qp->page_ext = meta->page_ext;
128: 	dbp->pgsize = meta->dbmeta.pagesize;
131: 	vdp->first_recno = meta->first_recno;
132: 	vdp->last_recno = meta->cur_recno;
# /home/ystatter/virunga/bdb/db-6.0.30/src/qam/qam_stat.c
70: 		sp->qs_nkeys = meta->dbmeta.key_count;
71: 		sp->qs_ndata = meta->dbmeta.record_count;
75: 	first = QAM_RECNO_PAGE(dbp, meta->first_recno);
76: 	last = QAM_RECNO_PAGE(dbp, meta->cur_recno);
144: 	/* Get the meta-data page. */
154: 		meta->dbmeta.key_count =
155: 		    meta->dbmeta.record_count = sp->qs_ndata;
160: 	sp->qs_magic = meta->dbmeta.magic;
161: 	sp->qs_version = meta->dbmeta.version;
162: 	sp->qs_metaflags = meta->dbmeta.flags;
163: 	sp->qs_pagesize = meta->dbmeta.pagesize;
164: 	sp->qs_extentsize = meta->page_ext;
165: 	sp->qs_re_len = meta->re_len;
166: 	sp->qs_re_pad = meta->re_pad;
167: 	sp->qs_first_recno = meta->first_recno;
168: 	sp->qs_cur_recno = meta->cur_recno;
170: 	/* Discard the meta-data page. */
# /home/ystatter/virunga/bdb/db-6.0.30/src/qam/qam_upgrade.c
42: 	newmeta->rec_page = oldmeta->rec_page;
43: 	newmeta->re_pad = oldmeta->re_pad;
44: 	newmeta->re_len = oldmeta->re_len;
45: 	newmeta->cur_recno = oldmeta->cur_recno;
46: 	newmeta->first_recno = oldmeta->first_recno;
47: 	newmeta->start = oldmeta->start;
48: 	memmove(newmeta->dbmeta.uid,
49: 	    oldmeta->dbmeta.uid, sizeof(oldmeta->dbmeta.uid));
50: 	newmeta->dbmeta.flags = oldmeta->dbmeta.flags;
51: 	newmeta->dbmeta.record_count = 0;
52: 	newmeta->dbmeta.key_count = 0;
53: 	ZERO_LSN(newmeta->dbmeta.unused3);
56: 	newmeta->dbmeta.version = 2;
87: 	newmeta->first_recno = oldmeta->first_recno;
88: 	newmeta->cur_recno = oldmeta->cur_recno;
89: 	newmeta->re_len = oldmeta->re_len;
90: 	newmeta->re_pad = oldmeta->re_pad;
91: 	newmeta->rec_page = oldmeta->rec_page;
92: 	newmeta->page_ext = 0;
94: 	newmeta->cur_recno++;
95: 	if (newmeta->first_recno == 0)
96: 		newmeta->first_recno = 1;
99: 	newmeta->dbmeta.version = 3;
# /home/ystatter/virunga/bdb/db-6.0.30/src/qam/qam.c
120: 	if (data->size > t->re_len)
121: 		return (__db_rec_toobig(env, data->size, t->re_len));
127: 		if (data->doff + data->dlen > t->re_len) {
134: 		if (data->size != data->dlen)
135: 			return (__db_rec_repl(env, data->size, data->dlen));
137: 		if (data->size == t->re_len)
172: 			dest += data->doff;
173: 			memcpy(dest, data->data, data->size);
176: 			p += data->doff;
302: 	if (meta->first_recno == meta->cur_recno) {
332: 	    &meta->dbmeta.lsn, 0, opcode, meta->first_recno,
333: 	    new_first, meta->cur_recno, new_cur,
334: 	    &meta->dbmeta.lsn, PGNO_BASE_MD)) != 0)
338: 		meta->cur_recno = new_cur;
340: 		meta->first_recno = new_first;
385: 	recno = meta->cur_recno;
386: 	QAM_INC_RECNO(meta->cur_recno);
388: 	if (meta->cur_recno == meta->first_recno) {
389: 		QAM_DEC_RECNO(meta->cur_recno);
395: 		meta->first_recno = recno;
533: 	first = meta->first_recno;
595: 		if (LF_ISSET(DB_CONSUME) || cp->recno == meta->first_recno)
706: 				cp->recno = meta->first_recno;
795: 		cp->recno = first = meta->first_recno;
801: 			if (cp->recno == meta->first_recno ||
811: 		if (meta->first_recno == meta->cur_recno) {
815: 		cp->recno = meta->cur_recno;
881: 		if ((is_first && cp->recno != meta->first_recno) ||
882: 		    (flags == DB_LAST && cp->recno != meta->cur_recno - 1)) {
1000: 		if (meta != NULL && cp->recno != meta->cur_recno) {
1006: 				    cp->recno, first, meta->cur_recno);
1009: 				    dbc->txn, &meta->dbmeta.lsn, 0,
1013: 				LSN_NOT_LOGGED(meta->dbmeta.lsn);
1015: 			meta->first_recno = cp->recno;
1016: 			QAM_INC_RECNO(meta->first_recno);
1056: 		    &dbc->rdata->data, &dbc->rdata->ulen)) != 0)
1158: 			    cp->recno, first, meta->first_recno);
1220: 	 *  2) update meta->first_recno.
1223: 	 * If we are not going to update meta->first_recno we
1235: 		first = meta->first_recno;
1260: 	current = meta->cur_recno;
1264: 	rec_extent = meta->page_ext * meta->rec_page;
1276: 		    (first % meta->rec_page == 0) ||
1283: 				    cp->pgno, first, meta->first_recno);
1342: 	if (ret == 0 && meta->first_recno != first && save_first != cp->recno) {
1348: 			    cp->recno, first, meta->first_recno);
1351: 			    dbc->txn, &meta->dbmeta.lsn, 0,
1355: 			LSN_NOT_LOGGED(meta->dbmeta.lsn);
1356: 		meta->first_recno = first;
1399: 	dbuf = data->data;
1403: 	space = (int)data->ulen;
1407: 	endp = (u_int32_t *)((u_int8_t *)dbuf + data->ulen);
1472: 							data->size = (u_int32_t)
1714: 	if (meta->cur_recno > 1 && ((QUEUE *)dbp->q_internal)->page_ext != 0) {
1716: 		    QAM_RECNO_PAGE(dbp, meta->cur_recno - 1))) != 0)
1721: 		ret = __qam_mvptr_log(dbp, dbc->txn, &meta->dbmeta.lsn, 0,
1722: 		    QAM_SETCUR | QAM_SETFIRST | QAM_TRUNCATE, meta->first_recno,
1723: 		    1, meta->cur_recno, 1, &meta->dbmeta.lsn, PGNO_BASE_MD);
1725: 		LSN_NOT_LOGGED(meta->dbmeta.lsn);
1727: 		meta->first_recno = meta->cur_recno = 1;
# /home/ystatter/virunga/bdb/db-6.0.30/src/qam/qam_open.c
89: 	if (qmeta->dbmeta.magic != DB_QAMMAGIC) {
98: 	t->page_ext = qmeta->page_ext;
106: 	t->re_pad = (int)qmeta->re_pad;
107: 	t->re_len = qmeta->re_len;
108: 	t->rec_page = qmeta->rec_page;
179: 	vers = qmeta->dbmeta.version;
211: 	dbp->pgsize = qmeta->dbmeta.pagesize;
214: 	memcpy(dbp->fileid, qmeta->dbmeta.uid, DB_FILE_ID_LEN);
225:  *	Initialize the meta-data for a Queue database.
239: 	LSN_NOT_LOGGED(meta->dbmeta.lsn);
240: 	meta->dbmeta.pgno = PGNO_BASE_MD;
241: 	meta->dbmeta.last_pgno = 0;
242: 	meta->dbmeta.magic = DB_QAMMAGIC;
243: 	meta->dbmeta.version = DB_QAMVERSION;
244: 	meta->dbmeta.pagesize = dbp->pgsize;
246: 		FLD_SET(meta->dbmeta.metaflags, DBMETA_CHKSUM);
248: 		meta->dbmeta.encrypt_alg = env->crypto_handle->alg;
249: 		DB_ASSERT(env, meta->dbmeta.encrypt_alg != 0);
250: 		meta->crypto_magic = meta->dbmeta.magic;
252: 	meta->dbmeta.type = P_QAMMETA;
253: 	meta->re_pad = (u_int32_t)t->re_pad;
254: 	meta->re_len = t->re_len;
255: 	meta->rec_page = CALC_QAM_RECNO_PER_PAGE(dbp);
256: 	meta->cur_recno = 1;
257: 	meta->first_recno = 1;
258: 	meta->page_ext = t->page_ext;
259: 	t->rec_page = meta->rec_page;
260: 	memcpy(meta->dbmeta.uid, dbp->fileid, DB_FILE_ID_LEN);
297: 	 * Build meta-data page.
318: 		    txn, &meta->dbmeta.lsn, pgno, (PAGE *)meta)) != 0)
# /home/ystatter/virunga/bdb/db-6.0.30/src/qam/qam_files.c
525: 	current = meta->cur_recno;
526: 	first = meta->first_recno;
# /home/ystatter/virunga/bdb/db-6.0.30/src/qam/qam_method.c
167: 	first = QAM_RECNO_PAGE(dbp, meta->first_recno);
169: 	    dbp, meta->cur_recno == 1 ? 1 : meta->cur_recno - 1);
171: 	empty = meta->cur_recno == meta->first_recno;
# /home/ystatter/virunga/bdb/db-6.0.30/src/heap/heap_verify.c
63: 	if ((ret = __db_vrfy_meta(dbp, vdp, &meta->dbmeta, pgno, flags)) != 0) {
75: 	h->region_size = meta->region_size;
76: 	last_pgno = meta->dbmeta.last_pgno;
77: 	if (meta->nregions != HEAP_REGION_NUM(dbp, last_pgno)) {
88: 	if (meta->gbytes != 0 || meta->bytes != 0) {
94: 		npgs = (db_pgno_t)(meta->gbytes * (GIGABYTE / dbp->pgsize));
95: 		npgs += (db_pgno_t)(meta->bytes / dbp->pgsize);
103: 		h->gbytes = meta->gbytes;
104: 		h->bytes = meta->bytes;
595: 	last = heapmeta->dbmeta.last_pgno;
# /home/ystatter/virunga/bdb/db-6.0.30/src/heap/heap_open.c
198: 	if (meta->dbmeta.magic == DB_HEAPMAGIC) {
199: 		h->curregion = meta->curregion;
201: 		h->gbytes = meta->gbytes;
202: 		h->bytes = meta->bytes;
203: 		h->region_size = meta->region_size;
206: 			__memp_set_last_pgno(mpf, meta->dbmeta.last_pgno);
269: 		/* Build the meta-data page. */
305: 		/* Build the meta-data page. */
404: 		    pgno, (u_int32_t)P_IHEAP, meta->dbmeta.last_pgno)) != 0)
407: 		LSN_NOT_LOGGED(LSN(&meta->dbmeta));
412: 	LSN(region) = LSN(&meta->dbmeta);
418: 	if (pgno > meta->dbmeta.last_pgno)
419: 		meta->dbmeta.last_pgno = pgno;
420: 	if (HEAP_REGION_NUM(dbp, pgno) > meta->nregions)
421: 		meta->nregions = HEAP_REGION_NUM(dbp, pgno);
450: 	meta->dbmeta.lsn = *lsnp;
451: 	meta->dbmeta.pgno = pgno;
452: 	meta->dbmeta.magic = DB_HEAPMAGIC;
453: 	meta->dbmeta.version = DB_HEAPVERSION;
454: 	meta->dbmeta.pagesize = dbp->pgsize;
456: 		FLD_SET(meta->dbmeta.metaflags, DBMETA_CHKSUM);
458: 		meta->dbmeta.encrypt_alg = env->crypto_handle->alg;
459: 		DB_ASSERT(env, meta->dbmeta.encrypt_alg != 0);
460: 		meta->crypto_magic = meta->dbmeta.magic;
462: 	meta->dbmeta.type = P_HEAPMETA;
463: 	meta->dbmeta.free = PGNO_INVALID;
464: 	meta->dbmeta.last_pgno = FIRST_HEAP_RPAGE;
465: 	memcpy(meta->dbmeta.uid, dbp->fileid, DB_FILE_ID_LEN);
466: 	meta->gbytes = h->gbytes;
467: 	meta->bytes = h->bytes;
468: 	meta->region_size = h->region_size;
469: 	meta->nregions = 1;
470: 	meta->curregion = 1;
471: 	meta->blob_threshold = dbp->blob_threshold;
# /home/ystatter/virunga/bdb/db-6.0.30/src/heap/heap_stat.c
63: 	sp->heap_metaflags = meta->dbmeta.flags;
64: 	sp->heap_pagecnt = meta->dbmeta.last_pgno + 1;
65: 	sp->heap_pagesize = meta->dbmeta.pagesize;
66: 	sp->heap_magic = meta->dbmeta.magic;
67: 	sp->heap_version = meta->dbmeta.version;
68: 	sp->heap_nregions = meta->nregions;
69: 	sp->heap_regionsize = meta->region_size;
72: 		sp->heap_nrecs = meta->dbmeta.record_count;
96: 			meta->dbmeta.key_count = sp->heap_nrecs;
97: 			meta->dbmeta.record_count = sp->heap_nrecs;
# /home/ystatter/virunga/bdb/db-6.0.30/src/heap/heap_reclaim.c
117: 		    meta->dbmeta.pgno, meta->dbmeta.last_pgno,
118: 		    meta->dbmeta.key_count, meta->dbmeta.record_count,
119: 		    meta->curregion, meta->nregions, &LSN(meta))) != 0)
123: 	meta->dbmeta.key_count = 0;
124: 	meta->dbmeta.record_count = 0;
125: 	meta->dbmeta.last_pgno = PGNO_BASE_MD + 1;
126: 	meta->curregion = 1;
127: 	meta->nregions = 1;
# /home/ystatter/virunga/bdb/db-6.0.30/src/heap/heap.c
169: 	dbuf = data->data;
173: 	space = data->ulen;
177: 	offp = (int32_t *)((u_int8_t *)dbuf + data->ulen);
237: 				data->size = (u_int32_t)DB_ALIGN(
238: 				    needed + data->ulen - space, 1024);
677: 		pgno = meta->dbmeta.last_pgno;
1024: 	doff = data->doff;
1027: 		dlen = data->dlen;
1028: 		data_size = doff + data->size;
1030: 		if (old_size - doff < data->dlen)
1033: 			dlen = data->dlen;
1034: 		data_size = old_size - dlen + data->size;
1082: 				data_size = doff + data->size;
1093: 			data_size = doff + (add_bytes ? data->size : 0);
1096: 				dlen + (add_bytes ? data->size : 0);
1123: 				memcpy(buf, data->data, data->size);
1132: 				memcpy(buf, data->data, data->size);
1133: 				buf += data->size;
1438: 	left = data->size;
1440: 	t_data.data = data->data;
1709: 		if (tot_size < data->doff) {
1711: 			dlen = data->dlen;
1712: 			data_size = data->doff + data->size;
1714: 			if (tot_size - data->doff < data->dlen)
1715: 				dlen = tot_size - data->doff;
1717: 				dlen = data->dlen;
1718: 			data_size = tot_size - dlen + data->size;
1723: 		data_size = data->size;
1757: 		 * Preserve data->doff bytes at the start, or all of the old
1761: 		if (data->doff > old_hdr->size) {
1764: 			memset(buf, '\0', data->doff - old_hdr->size);
1765: 			buf += data->doff - old_hdr->size;
1767: 			memcpy(buf, olddata, data->doff);
1768: 			buf += data->doff;
1772: 		memcpy(buf, data->data, data->size);
1773: 		buf += data->size;
1776: 		if (data->doff < old_hdr->size) {
1777: 			olddata += data->doff + data->dlen;
1779: 			    olddata, old_hdr->size - data->doff - data->dlen);
1786: 			    F_ISSET(((HEAPHDR *)data->data), HEAP_RECBLOB));
1787: 			new_data.data = HEAPBLOBREC_DATA(data->data);
1804: 		new_data.data = data->data;
2166: 				data_pgno, (u_int32_t)P_HEAP, meta->last_pgno);
2174: 		if (ret == 0 && data_pgno > meta->last_pgno)
2175: 			meta->last_pgno = data_pgno;
2277: 	    (data->size >= dbp->blob_threshold || F_ISSET(data, DB_DBT_BLOB)))
2286: 		data_size = DB_ALIGN(data->doff +
2287: 		    data->size + sizeof(HEAPHDR), sizeof(u_int32_t));
2290: 		    data->size + sizeof(HEAPHDR), sizeof(u_int32_t));
2318: 		hdr.size = data->size;
2320: 			hdr.size += data->doff;
2400: 	doff = data->doff;
2413: 	t_data.data = (u_int8_t *)data->data + data->size;
2414: 	left = data->size;
2416: 		left += data->doff;
2472: 		 * If DB_DBT_PARTIAL is set, once data->data is exhausted, we
2473: 		 * have to pad with data->doff bytes (or as much as can fit on
2475: 		 * from data->data.  Once that can't fill t_data, we have to
2480: 		    t_data.data >= data->data));
2500: 			memcpy(buf, data->data, left - doff);
2602: 	    sizeof(u_int32_t)) >= data->size);
2603: 	DB_ASSERT(dbp->env, nbytes >= hdr->size + data->size);
2620: 		memset(buf, 0, data->doff);
2621: 		buf += data->doff;
2623: 	memcpy(buf, data->data, data->size);
# /home/ystatter/virunga/bdb/db-6.0.30/src/heap/heap_rec.c
152: 		if (argp->pgno > meta->dbmeta.last_pgno)
153: 			meta->dbmeta.last_pgno = argp->pgno;
155: 		    HEAP_REGION_NUM(file_dbp, argp->pgno) > meta->nregions)
156: 			meta->nregions = HEAP_REGION_NUM(file_dbp, argp->pgno);
161: 		if (meta->dbmeta.last_pgno != argp->last_pgno) {
163: 			    meta->dbmeta.last_pgno)
165: 			meta->dbmeta.last_pgno = argp->last_pgno;
168: 		    HEAP_REGION_NUM(file_dbp, argp->pgno) == meta->nregions) {
170: 				meta->nregions--;
172: 			    (meta->nregions - 1) * HEAP_REGION_SIZE(file_dbp));
254: 	    (ret = __memp_ftruncate(mpf, NULL, ip, meta->dbmeta.last_pgno + 1,
303: 		meta->dbmeta.last_pgno = argp->last_pgno;
304: 		meta->dbmeta.key_count = argp->key_count;
305: 		meta->dbmeta.record_count = argp->record_count;
306: 		meta->curregion = argp->curregion;
307: 		meta->nregions = argp->nregions;
312: 		meta->dbmeta.last_pgno = 1;
313: 		meta->dbmeta.key_count = 0;
314: 		meta->dbmeta.record_count = 0;
315: 		meta->curregion = FIRST_HEAP_RPAGE;
316: 		meta->nregions = 1;
# /home/ystatter/virunga/bdb/db-6.0.30/src/heap/heap_upgrade.c
19:  * __heap_60_heapmeta--
42: 	hmeta->dbmeta.version = 2;
# /home/ystatter/virunga/bdb/db-6.0.30/src/log/log_verify_util.c
304: 	result->data = data->data;
305: 	result->size = data->size;
323: 	lvti = (VRFY_TIMESTAMP_INFO *)data->data;
535: 	data->data = buf;
536: 	data->size = (u_int32_t)bufsz;
537: 	data->flags |= DB_DBT_MALLOC;
608: 	txninfop = (VRFY_TXN_INFO *)data->data;
609: 	lsns = (DB_LSN *)((char *)data->data + TXN_VERIFY_INFO_FIXSIZE);
615: 	memcpy(buf, data->data, TXN_VERIFY_INFO_FIXSIZE);
1141: 	data->data = buf;
1142: 	data->size = (u_int32_t)bufsz;
1433: 	memcpy(buf, data->data, FILE_REG_INFO_FIXSIZE);
1435: 	p = ((char *)(data->data)) + FILE_REG_INFO_FIXSIZE;
# /home/ystatter/virunga/bdb/db-6.0.30/src/log/log_put.c
2006: 				LOGCOPY_32(env, bp, &data->size);
2007: 				bp += sizeof(data->size);
2008: 				memcpy(bp, data->data, data->size);
2011: 					__os_free(env, data->data);
2012: 				bp += data->size;
# /home/ystatter/virunga/bdb/db-6.0.30/src/dbreg/dbreg_rec.c
373: 		 * three ways we can detect this. 1) the meta-pgno in the
# /home/ystatter/virunga/bdb/db-6.0.30/src/dbreg/dbreg.c
941:  * meta-data may not be fully known, so we can't do a full dbregister.
# /home/ystatter/virunga/bdb/db-6.0.30/src/env/env_open.c
344: 	 * Currently we support one kind of mutex that is intra-process only,
# /home/ystatter/virunga/bdb/db-6.0.30/src/env/env_region.c
176: 	 * have the region here, just the meta-data, which implies that
180: 	 * something in the region file other than meta-data and that
# /home/ystatter/virunga/bdb/db-6.0.30/src/env/env_recover.c
259: 		 * In the recovery-to-a-timestamp case, lowlsn is chosen by
# /home/ystatter/virunga/bdb/db-6.0.30/examples/c/ex_bulk.c
740: 	memcpy(&ai, a->data, sizeof(int));
880: 	skey->data = ((struct data *)(data->data))->str;
# /home/ystatter/virunga/bdb/db-6.0.30/examples/c/ex_heap.c
642: 	memcpy(&ai, a->data, sizeof(int));
# /home/ystatter/virunga/bdb/db-6.0.30/examples/c/ex_btrec.c
202: 	    (int)data->size, (char *)data->data);
# /home/ystatter/virunga/bdb/db-6.0.30/build_android/db_int.h
993: 	if (c_data->compact_truncate > 1)		\
994: 		c_data->compact_truncate--;		\
# /home/ystatter/virunga/bdb/db-6.0.30/build_android/db.h
208: /* Key/data structure -- a Data-Base Thang. */
# /home/ystatter/virunga/bdb/db-6.0.30/build_android/db_config.h
305: /* Define to 1 to configure mutexes intra-process only. */
# /home/ystatter/virunga/bdb/db-6.0.30/build_unix/db_int.h
992: 	if (c_data->compact_truncate > 1)		\
993: 		c_data->compact_truncate--;		\
# /home/ystatter/virunga/bdb/db-6.0.30/build_unix/db.h
220: /* Key/data structure -- a Data-Base Thang. */
# /home/ystatter/virunga/bdb/db-6.0.30/build_unix/db_config.h
307: /* Define to 1 to configure mutexes intra-process only. */
# /home/ystatter/virunga/bdb/db-6.0.30/build_wince/db_int.h
993: 	if (c_data->compact_truncate > 1)		\
994: 		c_data->compact_truncate--;		\
# /home/ystatter/virunga/bdb/db-6.0.30/build_wince/db.h
251: /* Key/data structure -- a Data-Base Thang. */
# /home/ystatter/virunga/bdb/db-6.0.30/build_wince/db_config.h
319: /* Define to 1 to configure mutexes intra-process only. */
# /home/ystatter/virunga/ngspice/spmatrix.h
124:  *  operates on a row-at-a-time basis.  For speed, on each step, the row
# /home/ystatter/virunga/utils/reduced_characterize.tcl
89:     regsub -all {([a-zA-Z][a-zA-Z0-9_]*)} $expression {$\1} expression
90:     regsub -all {\$([a-zA-Z][a-zA-Z0-9_]*)\(} $expression {\1(} expression
91:     regsub -all {([0-9])\$([a-zA-Z])} $expression {\1\2} expression
132:         regsub -all {([a-zA-Z][a-zA-Z0-9_]*)=} $expressions {|||\1=} expressions
139:             regsub -all {([a-zA-Z][a-zA-Z0-9_]*)} $expression {$\1} expression
140:             regsub -all {\$([a-zA-Z][a-zA-Z0-9_]*)\(} $expression {\1(} expression
141:             regsub -all {([0-9])\$([a-zA-Z])} $expression {\1\2} expression
# /home/ystatter/virunga/Data/ctree.c
308:     if (l_index>=a->dim) {
313:     if (s_index>=a->size[l_index]) {
317:     a->legend[l_index][s_index]=atof(argv[4]);
318:     if (a->legend[l_index][1]!=a->legend[l_index][0]) a->physical_factor[l_index]=1.0/(a->legend[l_index][1]-a->legend[l_index][0]);
319:     a->hypercube_volume=1;
321:     for (i=0;i<a->dim;i++) a->hypercube_volume*=(a->legend[i][1]-a->legend[i][0]);
338:     if (l_index>=a->dim) {
343:     if (s_index>=a->size[l_index]) {
347:     tcl_append_float(interp,a->legend[l_index][s_index]);
363:     tcl_append_int(interp,a->dim);
380:     if (l_index>=a->dim) {
384:     tcl_append_int(interp,a->size[l_index]);
399:     for (i=1;i<a->dim;i++) maskW*=a->size[i-1];
400:     for (i=1;i<a->dim-1;i++) maskL*=a->size[i-1];
401:     int end=a->dim-1;
402:     for (i=0;i<maskW*a->size[end];i++) a->content[i]/=(a->legend[end][i/maskW]/a->legend[end-1][(i/maskL)%a->size[end-1]]);
420:     for (i=0;i<a->dim;i++) {
421:         volume*=a->size[i];
424:         tcl_append_float(interp,a->content[i]);
869:             get_float(&(a->content[offset+i]));
870:          //   #Info: "%ld+%ld  =  %g" offset i a->content[offset+i]
893:     for (i=0;i<a->dim;i++) {
894:         volume*=a->size[i];
915:         a->content[i]=atof(data[i]);
927:     write_string(O,a->name);
928:     write_ordinal(O,a->dim);
930:     for (i=0;i<a->dim;i++) write_ordinal(O,a->size[i]);
931:     for (i=0;i<a->dim;i++) for (j=0;j<a->size[i];j++) write_scalar(O,a->legend[i][j]);
933:     for (i=0;i<a->dim;i++) volume*=a->size[i];
934:     for (i=0;i<volume;i++) write_scalar(O,a->content[i]);
935:     if (a->LIT==NULL) {
941:     for (i=0;i<a->LIT->volume*(a->dim+1);i++) write_ordinal(O,a->LIT->content[i]);
955:             write_string(O,a->name);
956:             write_ordinal(O,a->dim);
958:             for (i=0;i<a->dim;i++) write_ordinal(O,a->size[i]);
959:             for (i=0;i<a->dim;i++) for (j=0;j<a->size[i];j++) write_scalar(O,a->legend[i][j]);
961:             for (i=0;i<a->dim;i++) volume*=a->size[i];
962:             for (i=0;i<volume;i++) write_float(O,a->content[i]);
963:             if (a->LIT==NULL) {
967:                 for (i=0;i<a->LIT->volume*(a->dim+1);i++) write_ordinal(O,a->LIT->content[i]);
987:             copy_string(a->name);
988:             a->dim=read_ordinal();
990: 	        if (a->dim==$dim) a->interpolate=lut_interpolation_$dim;
992:             a->size=(ordinal *)malloc(sizeof(ordinal)*a->dim);
993:             a->sizer=(ordinal *)malloc(sizeof(ordinal)*a->dim);
994:             a->legend=(ordinal **)malloc(sizeof(ordinal *)*a->dim);
995: 	    a->physical_factor=(float *)malloc(sizeof(scalar)*a->dim);
998:             for (j=0;j<a->dim;j++) {
999:                 a->size[j]=read_ordinal();
1000:                 a->legend[j]=(ordinal *)malloc(sizeof(ordinal)*a->size[j]);
1001:                 volume*=a->size[j];
1004:             for (j=0;j<a->dim;j++) {
1005:                 for (k=0;k<a->size[j];k++) {
1006:                     a->legend[j][k]=read_scalar();
1008: 		a->physical_factor[j]=1.0/(a->legend[j][1]-a->legend[j][0]);
1010:             a->hypercube_volume=1;
1011:             for (i=0;i<a->dim;i++) a->hypercube_volume*=(a->legend[i][1]-a->legend[i][0]);
1012: 	    a->sizer[0]=1;
1013: 	    for (i=1;i<a->dim;i++) a->sizer[i]=a->sizer[i-1]*a->size[i-1];
1014:             a->content=(float *)malloc(sizeof(float)*volume);
1016:                 a->content[i]=read_float();
1018:             ordinal num_of_corners=1<<a->dim;
1019:             a->neighbors=(ordinal *)malloc(sizeof(ordinal)*num_of_corners);
1026:                 for (i=0;i<a->dim;i++) {
1028:                     sizer*=a->size[i];
1032:                 a->neighbors[offset]=index;
1034:             a->LIT=NULL;
1035:             a->hit=NULL;
1039:                 a->LIT=L;
1040:                 L->dim=a->dim;
1047:                 for (i=0;i<a->dim;i++) {
1049:                     ordinal tmp=a->size[i];
1057:                     L->volume*=(a->size[i]-1);
1058:                     L->baseline[i]=a->legend[i][0];
1059:                     L->inv_step[i]=1/(a->legend[i][1]-a->legend[i][0]);
1061:                 ordinal num_of_corners=1<<a->dim;
1062:                 L->content=(float *)malloc(sizeof(scalar)*(1+a->dim)*L->volume);
1063:                 #Info: "Loading attached LIT[%ld]" L->volume*(a->dim+1)
1064:                 for (i=0;i<L->volume*(a->dim+1);i++) L->content[i]=read_scalar();
1065:                 #Info: "Done loading attached LIT[%ld]" L->volume*(a->dim+1)
1104:         a->name=name;
1105:         a->dim=read_ordinal();
1107: 	    if (a->dim==$dim) a->interpolate=lut_interpolation_$dim;
1109:         a->size=(ordinal *)malloc(sizeof(ordinal)*a->dim);
1110:         a->sizer=(ordinal *)malloc(sizeof(ordinal)*a->dim);
1111:         a->legend=(ordinal **)malloc(sizeof(ordinal *)*a->dim);
1112: 	a->physical_factor=(float *)malloc(sizeof(scalar)*a->dim);
1113:         a->LIT=NULL;
1114:         a->hit=NULL;
1116:         for (j=0;j<a->dim;j++) {
1117:             a->size[j]=read_ordinal();
1118:             a->legend[j]=(ordinal *)malloc(sizeof(ordinal)*a->size[j]);
1119:             volume*=a->size[j];
1122:         for (j=0;j<a->dim;j++) {
1123:             for (k=0;k<a->size[j];k++) {
1124:                 a->legend[j][k]=read_scalar();
1127:         a->hypercube_volume=1;
1128:         for (i=0;i<a->dim;i++) a->hypercube_volume*=(a->legend[i][1]-a->legend[i][0]);
1129: 	a->sizer[0]=1;
1130: 	for (i=1;i<a->dim;i++) a->sizer[i]=a->sizer[i-1]*a->size[i-1];
1131:         a->content=(float *)malloc(sizeof(scalar)*volume);
1133:             a->content[i]=read_scalar();
1135:         ordinal num_of_corners=1<<a->dim;
1136:         a->neighbors=(ordinal *)malloc(sizeof(ordinal)*num_of_corners);
1143:             for (i=0;i<a->dim;i++) {
1145:                 sizer*=a->size[i];
1149:             a->neighbors[offset]=index;
1154:             a->LIT=L;
1155:             L->dim=a->dim;
1162:             for (i=0;i<a->dim;i++) {
1164:                 ordinal tmp=a->size[i];
1172:                 L->volume*=(a->size[i]-1);
1173:                 L->baseline[i]=a->legend[i][0];
1174:                 L->inv_step[i]=1/(a->legend[i][1]-a->legend[i][0]);
1176:             ordinal num_of_corners=1<<a->dim;
1177:             L->content=(float *)malloc(sizeof(scalar)*(1+a->dim)*L->volume);
1178:             #Info: "Loading attached LIT[%ld]" L->volume*(a->dim+1)
1179:             for (i=0;i<L->volume*(a->dim+1);i++) L->content[i]=read_scalar();
1180:             #Info: "Done loading attached LIT[%ld]" L->volume*(a->dim+1)
1209:     if (argc-2!=a->dim) {
1210:         #Error: "(array_set) Array: %s has %d dimension, but accessed with %d indices" argv[1],a->dim,argc-2
1216:     for (i=0;i<a->dim;i++) {
1218:         offset*=a->size[i];
1220:     tcl_append_float(interp,a->content[index]);
1236:     if (argc-3!=a->dim) {
1237:         #Error: "(array_set) Array: %s has %d dimension, but accessed with %d indices" argv[1],a->dim,argc-3
1243:     for (i=0;i<a->dim;i++) {
1245:         offset*=a->size[i];
1247:     a->content[index]=atof(argv[argc-1]);
2011:             if (argc!=a->dim) {
2012:                 #Error: "(resolve_context) Array: %s has %d dimension, but accessed with %d indices" temp_context->name a->dim argc
2017:             for (l=0;l<a->dim;l++) {
2019:                 offset*=a->size[l];
2021:             *array_entry=&(a->content[index]);
2075:             a->name=strdup(context_name_buffer);
2083:             a->dim=argc;
2085: 	        if (a->dim==$dim) a->interpolate=lut_interpolation_$dim;
2087:             a->size=(ordinal *)malloc(sizeof(ordinal)*argc);
2088:             a->sizer=(ordinal *)malloc(sizeof(ordinal)*argc);
2090:             for (l=0;l<a->dim;l++) {
2091:                 a->size[l]=atoi(argv[l]);
2092:                 volume*=a->size[l];
2094:             a->content=(float *)malloc(sizeof(float)*volume);
2095:             for (l=0;l<volume;l++) a->content[l]=NAN;
2096:             a->legend=(float **)malloc(sizeof(float *)*a->dim);
2097: 	    a->physical_factor=(float *)malloc(sizeof(scalar)*a->dim);
2098:             for (l=0;l<a->dim;l++) {
2099:                 a->legend[l]=(float *)malloc(sizeof(scalar)*a->size[l]);
2101:                 for (j=0;j<a->size[l];j++) a->legend[l][j]=0;
2103: 	    a->sizer[0]=1;
2104: //	    for (i=1;i<a->dim;i++) a->sizer[i]=a->sizer[i-1]*a->size[i-1];
2105: 	    a->hypercube_volume=1;
2106:             ordinal num_of_corners=1<<a->dim;
2107:             a->neighbors=(ordinal *)malloc(sizeof(ordinal)*num_of_corners);
2114:                 for (l=0;l<a->dim;l++) {
2116:                     sizer*=a->size[l];
2120:                 a->neighbors[offset]=index;
2122:             a->LIT=NULL;
2123:             a->hit=NULL;
2259:         if (argc!=a->dim) {
2260:             #Error: "(ctree) Array: %s has %d dimension, but accessed with %d indices" temp_node->name,a->dim,argc
2266:         for (i=0;i<a->dim;i++) {
2268:             offset*=a->size[i];
2270:         *array_entry=&(a->content[index]);
2346:         a->name=(*i_node)->name;
2367:     a->name=(*i_node)->name;
2368:     a->dim=argc;
2370:     	if (a->dim==$dim) a->interpolate=lut_interpolation_$dim;
2372:     a->size=(ordinal *)malloc(sizeof(ordinal)*argc);
2373:     a->sizer=(ordinal *)malloc(sizeof(ordinal)*argc);
2375:     for (i=0;i<a->dim;i++) {
2376:         a->size[i]=atoi(argv[i]);
2377:         volume*=a->size[i];
2380:     a->content=(float *)malloc(sizeof(float)*volume);
2381:     for (i=0;i<volume;i++) a->content[i]=NAN;
2382:     a->legend=(float **)malloc(sizeof(float *)*a->dim);
2383:     a->physical_factor=(float *)malloc(sizeof(scalar)*argc);
2384:     for (i=0;i<a->dim;i++) {
2385:         a->legend[i]=(float *)malloc(sizeof(scalar)*a->size[i]);
2387:         for (j=0;j<a->size[i];j++) a->legend[i][j]=0;
2388: 	a->physical_factor[i]=1.0;
2390:     a->sizer[0]=1;
2391:     for (i=1;i<a->dim;i++) a->sizer[i]=a->sizer[i-1]*a->size[i-1];
2392:     a->hypercube_volume=1;
2393:     ordinal num_of_corners=1<<a->dim;
2394:     a->neighbors=(ordinal *)malloc(sizeof(ordinal)*num_of_corners);
2401:         for (i=0;i<a->dim;i++) {
2403:             sizer*=a->size[i];
2407:         a->neighbors[offset]=index;
2409:     a->LIT=NULL;
2410:     a->hit=NULL;
2652:         if (argc-3!=a->dim) {
2653:             #Error: "(ctree) Array %s has %d dimentions. Can't interpolate with %d coordinates." a->name a->dim argc-3
2657:         for (i=0;i<a->dim;i++) global_coord[i]=atof(argv[i+3]);
2658:         tcl_append_float(interp,a->interpolate(a,global_coord));
3346:     bc_start(a->hit_bytecode);
3347:     ordinal limit=a->hit_bytecode_size;
3349:     if (limit>a->hit_bytecode_size) limit=a->hit_bytecode_size;
3366:     bc_start(a->hit_bytecode);
3378:     for (i=0;i<a->dim;i++) array2hit_partial_legend_top[i]=a->size[i];
3379:     for (i=0;i<a->dim;i++) array2hit_partial_legend_bottom[i]=0;
3382:     a->hit=array2hit(a,separation,0);
3383:     for (i=0;i<a->dim;i++) free(separation[i]);
3384:     merge_dim=a->dim;
3386:     m=merge_hit_leaves(&(a->hit));
3391: //    a->hit=linearize_hit_leaf(a->hit,stats);
3393:     for (i=0;i<a->dim;i++) sizer*=(a->size[i]-1);
3394:     bc_start(a->hit_bytecode);
3395:     ordinal num_of_bc_words=count_hit_bytecode(a->hit);
3398:     a->hit_bytecode=(FC *)malloc(sizeof(FC)*num_of_bc_words);
3399:     a->hit_bytecode_size=num_of_bc_words;
3400:     bc_start(a->hit_bytecode);
3401:     compile_bytecode(a->hit);
3404:     free(a->content);
3405:     bc_start(a->hit_bytecode);
3411:     for (i=0;i<a->dim;i++) {
3412:         separation[i]=(ordinal *)malloc(sizeof(ordinal)*a->size[i]);
3413:         total[i]=(ordinal *)malloc(sizeof(ordinal)*a->size[i]);
3414:         for (j=0;j<a->size[i];j++) separation[i][j]=0;
3415:         for (j=0;j<a->size[i];j++) total[i][j]=0;
3418:     for (i=0;i<a->dim;i++) {
3419:         //        a->neighbors[i]=sizer;
3420:         sizer*=a->size[i];
3426:         for (j=0;j<a->dim;j++) {
3427:             key[j]=partial_index%a->size[j];
3429:             if (key[j]==a->size[j]-1) skip_point=1;
3430:             partial_index/=a->size[j];
3433:         for (j=0;j<a->dim;j++) {
3435:             float weight=(a->legend[j][slice+1]-a->legend[j][slice])/(a->legend[j][slice+1]-a->legend[j][slice-1]);
3436:             float pre=a->content[index-a->neighbors[j]];
3437:             float post=a->content[index+a->neighbors[j]];
3438:             float M=a->content[index];
3445:     for (i=0;i<a->dim;i++) for (j=1;j<a->size[i]-1;j++) {
3450:     for (i=0;i<a->dim;i++) {
3602:     for (i=0;i<a->dim;i++) {
3616:         for (i=0;i<a->dim;i++) if (array2hit_partial_legend_top[i]-array2hit_partial_legend_bottom[i]>max_width) {
3629:         hit[HIT_VALUES+0].s=a->legend[seperation_dim][separation_slice];
3640:     num_of_corners=1<<a->dim;
3643:     for (i=0;i<a->dim;i++) {
3645:         sizer*=a->size[i];
3647:     hit_node *hit=(hit_node *)malloc(sizeof(hit_node)*(2+num_of_corners+a->dim*2));
3650:     for (i=0;i<a->dim;i++) {
3651:         hit[HIT_VALUES+i*2].s=-a->legend[i][array2hit_partial_legend_bottom[i]];
3652:         hit[HIT_VALUES+i*2+1].s=1.0/(a->legend[i][array2hit_partial_legend_top[i]]-a->legend[i][array2hit_partial_legend_bottom[i]]);
3656:         for (j=0;j<a->dim;j++) if (i&(1<<j)) if (array2hit_partial_legend_top[j]>=a->size[j]) outsider=1;
3658: 	    hit[HIT_VALUES+i+a->dim*2].s=NAN;
3660:             hit[HIT_VALUES+i+a->dim*2].s=a->content[index+a->neighbors[i]]; 
# /home/ystatter/virunga/VM/commands/lut_interpolation_4.c
12:     int key0=s2o((coord0-a->legend[0][0])*a->physical_factor[0]);
14:     if (key0>=a->size[0]-1) key0=a->size[0]-2;
16:     sizer*=a->size[0];
19:     int key1=s2o((coord1-a->legend[1][0])*a->physical_factor[1]);
21:     if (key1>=a->size[1]-1) key1=a->size[1]-2;
23:     sizer*=a->size[1];
26:     int key2=s2o((coord2-a->legend[2][0])*a->physical_factor[2]);
28:     if (key2>=a->size[2]-1) key2=a->size[2]-2;
30:     sizer*=a->size[2];
33:     int key3=s2o((coord3-a->legend[3][0])*a->physical_factor[3]);
35:     if (key3>=a->size[3]-1) key3=a->size[3]-2;
37:     sizer*=a->size[3];
38:     float interpolation_buffer0=a->content[index+a->neighbors[0]];
39:     float interpolation_buffer1=a->content[index+a->neighbors[1]];
40:     float interpolation_buffer2=a->content[index+a->neighbors[2]];
41:     float interpolation_buffer3=a->content[index+a->neighbors[3]];
42:     float interpolation_buffer4=a->content[index+a->neighbors[4]];
43:     float interpolation_buffer5=a->content[index+a->neighbors[5]];
44:     float interpolation_buffer6=a->content[index+a->neighbors[6]];
45:     float interpolation_buffer7=a->content[index+a->neighbors[7]];
46:     float interpolation_buffer8=a->content[index+a->neighbors[8]];
47:     float interpolation_buffer9=a->content[index+a->neighbors[9]];
48:     float interpolation_buffer10=a->content[index+a->neighbors[10]];
49:     float interpolation_buffer11=a->content[index+a->neighbors[11]];
50:     float interpolation_buffer12=a->content[index+a->neighbors[12]];
51:     float interpolation_buffer13=a->content[index+a->neighbors[13]];
52:     float interpolation_buffer14=a->content[index+a->neighbors[14]];
53:     float interpolation_buffer15=a->content[index+a->neighbors[15]];
56:     interpolation_buffer0=interpolation_buffer1*(coord0-a->legend[0][key0])+interpolation_buffer0*(a->legend[0][key0+1]-coord0);
57: interpolation_buffer1=interpolation_buffer3*(coord0-a->legend[0][key0])+interpolation_buffer2*(a->legend[0][key0+1]-coord0);
58: interpolation_buffer2=interpolation_buffer5*(coord0-a->legend[0][key0])+interpolation_buffer4*(a->legend[0][key0+1]-coord0);
59: interpolation_buffer3=interpolation_buffer7*(coord0-a->legend[0][key0])+interpolation_buffer6*(a->legend[0][key0+1]-coord0);
60: interpolation_buffer4=interpolation_buffer9*(coord0-a->legend[0][key0])+interpolation_buffer8*(a->legend[0][key0+1]-coord0);
61: interpolation_buffer5=interpolation_buffer11*(coord0-a->legend[0][key0])+interpolation_buffer10*(a->legend[0][key0+1]-coord0);
62: interpolation_buffer6=interpolation_buffer13*(coord0-a->legend[0][key0])+interpolation_buffer12*(a->legend[0][key0+1]-coord0);
63: interpolation_buffer7=interpolation_buffer15*(coord0-a->legend[0][key0])+interpolation_buffer14*(a->legend[0][key0+1]-coord0);
64: hyper_volume*=(a->legend[0][key0+1]-a->legend[0][key0]);
65: interpolation_buffer0=interpolation_buffer1*(coord1-a->legend[1][key1])+interpolation_buffer0*(a->legend[1][key1+1]-coord1);
66: interpolation_buffer1=interpolation_buffer3*(coord1-a->legend[1][key1])+interpolation_buffer2*(a->legend[1][key1+1]-coord1);
67: interpolation_buffer2=interpolation_buffer5*(coord1-a->legend[1][key1])+interpolation_buffer4*(a->legend[1][key1+1]-coord1);
68: interpolation_buffer3=interpolation_buffer7*(coord1-a->legend[1][key1])+interpolation_buffer6*(a->legend[1][key1+1]-coord1);
69: hyper_volume*=(a->legend[1][key1+1]-a->legend[1][key1]);
70: interpolation_buffer0=interpolation_buffer1*(coord2-a->legend[2][key2])+interpolation_buffer0*(a->legend[2][key2+1]-coord2);
71: interpolation_buffer1=interpolation_buffer3*(coord2-a->legend[2][key2])+interpolation_buffer2*(a->legend[2][key2+1]-coord2);
72: hyper_volume*=(a->legend[2][key2+1]-a->legend[2][key2]);
73: interpolation_buffer0=interpolation_buffer1*(coord3-a->legend[3][key3])+interpolation_buffer0*(a->legend[3][key3+1]-coord3);
74: hyper_volume*=(a->legend[3][key3+1]-a->legend[3][key3]);
# /home/ystatter/virunga/VM/commands/lut_interpolation_3.c
12:     int key0=s2o((coord0-a->legend[0][0])*a->physical_factor[0]);
14:     if (key0>=a->size[0]-1) key0=a->size[0]-2;
16:     sizer*=a->size[0];
19:     int key1=s2o((coord1-a->legend[1][0])*a->physical_factor[1]);
21:     if (key1>=a->size[1]-1) key1=a->size[1]-2;
23:     sizer*=a->size[1];
26:     int key2=s2o((coord2-a->legend[2][0])*a->physical_factor[2]);
28:     if (key2>=a->size[2]-1) key2=a->size[2]-2;
30:     sizer*=a->size[2];
31:     float interpolation_buffer0=a->content[index+a->neighbors[0]];
32:     float interpolation_buffer1=a->content[index+a->neighbors[1]];
33:     float interpolation_buffer2=a->content[index+a->neighbors[2]];
34:     float interpolation_buffer3=a->content[index+a->neighbors[3]];
35:     float interpolation_buffer4=a->content[index+a->neighbors[4]];
36:     float interpolation_buffer5=a->content[index+a->neighbors[5]];
37:     float interpolation_buffer6=a->content[index+a->neighbors[6]];
38:     float interpolation_buffer7=a->content[index+a->neighbors[7]];
41:     interpolation_buffer0=interpolation_buffer1*(coord0-a->legend[0][key0])+interpolation_buffer0*(a->legend[0][key0+1]-coord0);
42: interpolation_buffer1=interpolation_buffer3*(coord0-a->legend[0][key0])+interpolation_buffer2*(a->legend[0][key0+1]-coord0);
43: interpolation_buffer2=interpolation_buffer5*(coord0-a->legend[0][key0])+interpolation_buffer4*(a->legend[0][key0+1]-coord0);
44: interpolation_buffer3=interpolation_buffer7*(coord0-a->legend[0][key0])+interpolation_buffer6*(a->legend[0][key0+1]-coord0);
45: hyper_volume*=(a->legend[0][key0+1]-a->legend[0][key0]);
46: interpolation_buffer0=interpolation_buffer1*(coord1-a->legend[1][key1])+interpolation_buffer0*(a->legend[1][key1+1]-coord1);
47: interpolation_buffer1=interpolation_buffer3*(coord1-a->legend[1][key1])+interpolation_buffer2*(a->legend[1][key1+1]-coord1);
48: hyper_volume*=(a->legend[1][key1+1]-a->legend[1][key1]);
49: interpolation_buffer0=interpolation_buffer1*(coord2-a->legend[2][key2])+interpolation_buffer0*(a->legend[2][key2+1]-coord2);
50: hyper_volume*=(a->legend[2][key2+1]-a->legend[2][key2]);
# /home/ystatter/virunga/VM/commands/lut_interpolation_2.c
12:     int key0=s2o((coord0-a->legend[0][0])*a->physical_factor[0]);
14:     if (key0>=a->size[0]-1) key0=a->size[0]-2;
16:     sizer*=a->size[0];
19:     int key1=s2o((coord1-a->legend[1][0])*a->physical_factor[1]);
21:     if (key1>=a->size[1]-1) key1=a->size[1]-2;
23:     sizer*=a->size[1];
24:     float interpolation_buffer0=a->content[index+a->neighbors[0]];
25:     float interpolation_buffer1=a->content[index+a->neighbors[1]];
26:     float interpolation_buffer2=a->content[index+a->neighbors[2]];
27:     float interpolation_buffer3=a->content[index+a->neighbors[3]];
30:     interpolation_buffer0=interpolation_buffer1*(coord0-a->legend[0][key0])+interpolation_buffer0*(a->legend[0][key0+1]-coord0);
31: interpolation_buffer1=interpolation_buffer3*(coord0-a->legend[0][key0])+interpolation_buffer2*(a->legend[0][key0+1]-coord0);
32: hyper_volume*=(a->legend[0][key0+1]-a->legend[0][key0]);
33: interpolation_buffer0=interpolation_buffer1*(coord1-a->legend[1][key1])+interpolation_buffer0*(a->legend[1][key1+1]-coord1);
34: hyper_volume*=(a->legend[1][key1+1]-a->legend[1][key1]);
# /home/ystatter/virunga/VM/commands/lut_interpolation_6.c
12:     int key0=s2o((coord0-a->legend[0][0])*a->physical_factor[0]);
14:     if (key0>=a->size[0]-1) key0=a->size[0]-2;
16:     sizer*=a->size[0];
19:     int key1=s2o((coord1-a->legend[1][0])*a->physical_factor[1]);
21:     if (key1>=a->size[1]-1) key1=a->size[1]-2;
23:     sizer*=a->size[1];
26:     int key2=s2o((coord2-a->legend[2][0])*a->physical_factor[2]);
28:     if (key2>=a->size[2]-1) key2=a->size[2]-2;
30:     sizer*=a->size[2];
33:     int key3=s2o((coord3-a->legend[3][0])*a->physical_factor[3]);
35:     if (key3>=a->size[3]-1) key3=a->size[3]-2;
37:     sizer*=a->size[3];
40:     int key4=s2o((coord4-a->legend[4][0])*a->physical_factor[4]);
42:     if (key4>=a->size[4]-1) key4=a->size[4]-2;
44:     sizer*=a->size[4];
47:     int key5=s2o((coord5-a->legend[5][0])*a->physical_factor[5]);
49:     if (key5>=a->size[5]-1) key5=a->size[5]-2;
51:     sizer*=a->size[5];
52:     float interpolation_buffer0=a->content[index+a->neighbors[0]];
53:     float interpolation_buffer1=a->content[index+a->neighbors[1]];
54:     float interpolation_buffer2=a->content[index+a->neighbors[2]];
55:     float interpolation_buffer3=a->content[index+a->neighbors[3]];
56:     float interpolation_buffer4=a->content[index+a->neighbors[4]];
57:     float interpolation_buffer5=a->content[index+a->neighbors[5]];
58:     float interpolation_buffer6=a->content[index+a->neighbors[6]];
59:     float interpolation_buffer7=a->content[index+a->neighbors[7]];
60:     float interpolation_buffer8=a->content[index+a->neighbors[8]];
61:     float interpolation_buffer9=a->content[index+a->neighbors[9]];
62:     float interpolation_buffer10=a->content[index+a->neighbors[10]];
63:     float interpolation_buffer11=a->content[index+a->neighbors[11]];
64:     float interpolation_buffer12=a->content[index+a->neighbors[12]];
65:     float interpolation_buffer13=a->content[index+a->neighbors[13]];
66:     float interpolation_buffer14=a->content[index+a->neighbors[14]];
67:     float interpolation_buffer15=a->content[index+a->neighbors[15]];
68:     float interpolation_buffer16=a->content[index+a->neighbors[16]];
69:     float interpolation_buffer17=a->content[index+a->neighbors[17]];
70:     float interpolation_buffer18=a->content[index+a->neighbors[18]];
71:     float interpolation_buffer19=a->content[index+a->neighbors[19]];
72:     float interpolation_buffer20=a->content[index+a->neighbors[20]];
73:     float interpolation_buffer21=a->content[index+a->neighbors[21]];
74:     float interpolation_buffer22=a->content[index+a->neighbors[22]];
75:     float interpolation_buffer23=a->content[index+a->neighbors[23]];
76:     float interpolation_buffer24=a->content[index+a->neighbors[24]];
77:     float interpolation_buffer25=a->content[index+a->neighbors[25]];
78:     float interpolation_buffer26=a->content[index+a->neighbors[26]];
79:     float interpolation_buffer27=a->content[index+a->neighbors[27]];
80:     float interpolation_buffer28=a->content[index+a->neighbors[28]];
81:     float interpolation_buffer29=a->content[index+a->neighbors[29]];
82:     float interpolation_buffer30=a->content[index+a->neighbors[30]];
83:     float interpolation_buffer31=a->content[index+a->neighbors[31]];
84:     float interpolation_buffer32=a->content[index+a->neighbors[32]];
85:     float interpolation_buffer33=a->content[index+a->neighbors[33]];
86:     float interpolation_buffer34=a->content[index+a->neighbors[34]];
87:     float interpolation_buffer35=a->content[index+a->neighbors[35]];
88:     float interpolation_buffer36=a->content[index+a->neighbors[36]];
89:     float interpolation_buffer37=a->content[index+a->neighbors[37]];
90:     float interpolation_buffer38=a->content[index+a->neighbors[38]];
91:     float interpolation_buffer39=a->content[index+a->neighbors[39]];
92:     float interpolation_buffer40=a->content[index+a->neighbors[40]];
93:     float interpolation_buffer41=a->content[index+a->neighbors[41]];
94:     float interpolation_buffer42=a->content[index+a->neighbors[42]];
95:     float interpolation_buffer43=a->content[index+a->neighbors[43]];
96:     float interpolation_buffer44=a->content[index+a->neighbors[44]];
97:     float interpolation_buffer45=a->content[index+a->neighbors[45]];
98:     float interpolation_buffer46=a->content[index+a->neighbors[46]];
99:     float interpolation_buffer47=a->content[index+a->neighbors[47]];
100:     float interpolation_buffer48=a->content[index+a->neighbors[48]];
101:     float interpolation_buffer49=a->content[index+a->neighbors[49]];
102:     float interpolation_buffer50=a->content[index+a->neighbors[50]];
103:     float interpolation_buffer51=a->content[index+a->neighbors[51]];
104:     float interpolation_buffer52=a->content[index+a->neighbors[52]];
105:     float interpolation_buffer53=a->content[index+a->neighbors[53]];
106:     float interpolation_buffer54=a->content[index+a->neighbors[54]];
107:     float interpolation_buffer55=a->content[index+a->neighbors[55]];
108:     float interpolation_buffer56=a->content[index+a->neighbors[56]];
109:     float interpolation_buffer57=a->content[index+a->neighbors[57]];
110:     float interpolation_buffer58=a->content[index+a->neighbors[58]];
111:     float interpolation_buffer59=a->content[index+a->neighbors[59]];
112:     float interpolation_buffer60=a->content[index+a->neighbors[60]];
113:     float interpolation_buffer61=a->content[index+a->neighbors[61]];
114:     float interpolation_buffer62=a->content[index+a->neighbors[62]];
115:     float interpolation_buffer63=a->content[index+a->neighbors[63]];
118:     interpolation_buffer0=interpolation_buffer1*(coord0-a->legend[0][key0])+interpolation_buffer0*(a->legend[0][key0+1]-coord0);
119: interpolation_buffer1=interpolation_buffer3*(coord0-a->legend[0][key0])+interpolation_buffer2*(a->legend[0][key0+1]-coord0);
120: interpolation_buffer2=interpolation_buffer5*(coord0-a->legend[0][key0])+interpolation_buffer4*(a->legend[0][key0+1]-coord0);
121: interpolation_buffer3=interpolation_buffer7*(coord0-a->legend[0][key0])+interpolation_buffer6*(a->legend[0][key0+1]-coord0);
122: interpolation_buffer4=interpolation_buffer9*(coord0-a->legend[0][key0])+interpolation_buffer8*(a->legend[0][key0+1]-coord0);
123: interpolation_buffer5=interpolation_buffer11*(coord0-a->legend[0][key0])+interpolation_buffer10*(a->legend[0][key0+1]-coord0);
124: interpolation_buffer6=interpolation_buffer13*(coord0-a->legend[0][key0])+interpolation_buffer12*(a->legend[0][key0+1]-coord0);
125: interpolation_buffer7=interpolation_buffer15*(coord0-a->legend[0][key0])+interpolation_buffer14*(a->legend[0][key0+1]-coord0);
126: interpolation_buffer8=interpolation_buffer17*(coord0-a->legend[0][key0])+interpolation_buffer16*(a->legend[0][key0+1]-coord0);
127: interpolation_buffer9=interpolation_buffer19*(coord0-a->legend[0][key0])+interpolation_buffer18*(a->legend[0][key0+1]-coord0);
128: interpolation_buffer10=interpolation_buffer21*(coord0-a->legend[0][key0])+interpolation_buffer20*(a->legend[0][key0+1]-coord0);
129: interpolation_buffer11=interpolation_buffer23*(coord0-a->legend[0][key0])+interpolation_buffer22*(a->legend[0][key0+1]-coord0);
130: interpolation_buffer12=interpolation_buffer25*(coord0-a->legend[0][key0])+interpolation_buffer24*(a->legend[0][key0+1]-coord0);
131: interpolation_buffer13=interpolation_buffer27*(coord0-a->legend[0][key0])+interpolation_buffer26*(a->legend[0][key0+1]-coord0);
132: interpolation_buffer14=interpolation_buffer29*(coord0-a->legend[0][key0])+interpolation_buffer28*(a->legend[0][key0+1]-coord0);
133: interpolation_buffer15=interpolation_buffer31*(coord0-a->legend[0][key0])+interpolation_buffer30*(a->legend[0][key0+1]-coord0);
134: interpolation_buffer16=interpolation_buffer33*(coord0-a->legend[0][key0])+interpolation_buffer32*(a->legend[0][key0+1]-coord0);
135: interpolation_buffer17=interpolation_buffer35*(coord0-a->legend[0][key0])+interpolation_buffer34*(a->legend[0][key0+1]-coord0);
136: interpolation_buffer18=interpolation_buffer37*(coord0-a->legend[0][key0])+interpolation_buffer36*(a->legend[0][key0+1]-coord0);
137: interpolation_buffer19=interpolation_buffer39*(coord0-a->legend[0][key0])+interpolation_buffer38*(a->legend[0][key0+1]-coord0);
138: interpolation_buffer20=interpolation_buffer41*(coord0-a->legend[0][key0])+interpolation_buffer40*(a->legend[0][key0+1]-coord0);
139: interpolation_buffer21=interpolation_buffer43*(coord0-a->legend[0][key0])+interpolation_buffer42*(a->legend[0][key0+1]-coord0);
140: interpolation_buffer22=interpolation_buffer45*(coord0-a->legend[0][key0])+interpolation_buffer44*(a->legend[0][key0+1]-coord0);
141: interpolation_buffer23=interpolation_buffer47*(coord0-a->legend[0][key0])+interpolation_buffer46*(a->legend[0][key0+1]-coord0);
142: interpolation_buffer24=interpolation_buffer49*(coord0-a->legend[0][key0])+interpolation_buffer48*(a->legend[0][key0+1]-coord0);
143: interpolation_buffer25=interpolation_buffer51*(coord0-a->legend[0][key0])+interpolation_buffer50*(a->legend[0][key0+1]-coord0);
144: interpolation_buffer26=interpolation_buffer53*(coord0-a->legend[0][key0])+interpolation_buffer52*(a->legend[0][key0+1]-coord0);
145: interpolation_buffer27=interpolation_buffer55*(coord0-a->legend[0][key0])+interpolation_buffer54*(a->legend[0][key0+1]-coord0);
146: interpolation_buffer28=interpolation_buffer57*(coord0-a->legend[0][key0])+interpolation_buffer56*(a->legend[0][key0+1]-coord0);
147: interpolation_buffer29=interpolation_buffer59*(coord0-a->legend[0][key0])+interpolation_buffer58*(a->legend[0][key0+1]-coord0);
148: interpolation_buffer30=interpolation_buffer61*(coord0-a->legend[0][key0])+interpolation_buffer60*(a->legend[0][key0+1]-coord0);
149: interpolation_buffer31=interpolation_buffer63*(coord0-a->legend[0][key0])+interpolation_buffer62*(a->legend[0][key0+1]-coord0);
150: hyper_volume*=(a->legend[0][key0+1]-a->legend[0][key0]);
151: interpolation_buffer0=interpolation_buffer1*(coord1-a->legend[1][key1])+interpolation_buffer0*(a->legend[1][key1+1]-coord1);
152: interpolation_buffer1=interpolation_buffer3*(coord1-a->legend[1][key1])+interpolation_buffer2*(a->legend[1][key1+1]-coord1);
153: interpolation_buffer2=interpolation_buffer5*(coord1-a->legend[1][key1])+interpolation_buffer4*(a->legend[1][key1+1]-coord1);
154: interpolation_buffer3=interpolation_buffer7*(coord1-a->legend[1][key1])+interpolation_buffer6*(a->legend[1][key1+1]-coord1);
155: interpolation_buffer4=interpolation_buffer9*(coord1-a->legend[1][key1])+interpolation_buffer8*(a->legend[1][key1+1]-coord1);
156: interpolation_buffer5=interpolation_buffer11*(coord1-a->legend[1][key1])+interpolation_buffer10*(a->legend[1][key1+1]-coord1);
157: interpolation_buffer6=interpolation_buffer13*(coord1-a->legend[1][key1])+interpolation_buffer12*(a->legend[1][key1+1]-coord1);
158: interpolation_buffer7=interpolation_buffer15*(coord1-a->legend[1][key1])+interpolation_buffer14*(a->legend[1][key1+1]-coord1);
159: interpolation_buffer8=interpolation_buffer17*(coord1-a->legend[1][key1])+interpolation_buffer16*(a->legend[1][key1+1]-coord1);
160: interpolation_buffer9=interpolation_buffer19*(coord1-a->legend[1][key1])+interpolation_buffer18*(a->legend[1][key1+1]-coord1);
161: interpolation_buffer10=interpolation_buffer21*(coord1-a->legend[1][key1])+interpolation_buffer20*(a->legend[1][key1+1]-coord1);
162: interpolation_buffer11=interpolation_buffer23*(coord1-a->legend[1][key1])+interpolation_buffer22*(a->legend[1][key1+1]-coord1);
163: interpolation_buffer12=interpolation_buffer25*(coord1-a->legend[1][key1])+interpolation_buffer24*(a->legend[1][key1+1]-coord1);
164: interpolation_buffer13=interpolation_buffer27*(coord1-a->legend[1][key1])+interpolation_buffer26*(a->legend[1][key1+1]-coord1);
165: interpolation_buffer14=interpolation_buffer29*(coord1-a->legend[1][key1])+interpolation_buffer28*(a->legend[1][key1+1]-coord1);
166: interpolation_buffer15=interpolation_buffer31*(coord1-a->legend[1][key1])+interpolation_buffer30*(a->legend[1][key1+1]-coord1);
167: hyper_volume*=(a->legend[1][key1+1]-a->legend[1][key1]);
168: interpolation_buffer0=interpolation_buffer1*(coord2-a->legend[2][key2])+interpolation_buffer0*(a->legend[2][key2+1]-coord2);
169: interpolation_buffer1=interpolation_buffer3*(coord2-a->legend[2][key2])+interpolation_buffer2*(a->legend[2][key2+1]-coord2);
170: interpolation_buffer2=interpolation_buffer5*(coord2-a->legend[2][key2])+interpolation_buffer4*(a->legend[2][key2+1]-coord2);
171: interpolation_buffer3=interpolation_buffer7*(coord2-a->legend[2][key2])+interpolation_buffer6*(a->legend[2][key2+1]-coord2);
172: interpolation_buffer4=interpolation_buffer9*(coord2-a->legend[2][key2])+interpolation_buffer8*(a->legend[2][key2+1]-coord2);
173: interpolation_buffer5=interpolation_buffer11*(coord2-a->legend[2][key2])+interpolation_buffer10*(a->legend[2][key2+1]-coord2);
174: interpolation_buffer6=interpolation_buffer13*(coord2-a->legend[2][key2])+interpolation_buffer12*(a->legend[2][key2+1]-coord2);
175: interpolation_buffer7=interpolation_buffer15*(coord2-a->legend[2][key2])+interpolation_buffer14*(a->legend[2][key2+1]-coord2);
176: hyper_volume*=(a->legend[2][key2+1]-a->legend[2][key2]);
177: interpolation_buffer0=interpolation_buffer1*(coord3-a->legend[3][key3])+interpolation_buffer0*(a->legend[3][key3+1]-coord3);
178: interpolation_buffer1=interpolation_buffer3*(coord3-a->legend[3][key3])+interpolation_buffer2*(a->legend[3][key3+1]-coord3);
179: interpolation_buffer2=interpolation_buffer5*(coord3-a->legend[3][key3])+interpolation_buffer4*(a->legend[3][key3+1]-coord3);
180: interpolation_buffer3=interpolation_buffer7*(coord3-a->legend[3][key3])+interpolation_buffer6*(a->legend[3][key3+1]-coord3);
181: hyper_volume*=(a->legend[3][key3+1]-a->legend[3][key3]);
182: interpolation_buffer0=interpolation_buffer1*(coord4-a->legend[4][key4])+interpolation_buffer0*(a->legend[4][key4+1]-coord4);
183: interpolation_buffer1=interpolation_buffer3*(coord4-a->legend[4][key4])+interpolation_buffer2*(a->legend[4][key4+1]-coord4);
184: hyper_volume*=(a->legend[4][key4+1]-a->legend[4][key4]);
185: interpolation_buffer0=interpolation_buffer1*(coord5-a->legend[5][key5])+interpolation_buffer0*(a->legend[5][key5+1]-coord5);
186: hyper_volume*=(a->legend[5][key5+1]-a->legend[5][key5]);
# /home/ystatter/virunga/VM/commands/lut_interpolation_1.c
12:     int key0=s2o((coord0-a->legend[0][0])*a->physical_factor[0]);
14:     if (key0>=a->size[0]-1) key0=a->size[0]-2;
16:     sizer*=a->size[0];
17:     float interpolation_buffer0=a->content[index+a->neighbors[0]];
18:     float interpolation_buffer1=a->content[index+a->neighbors[1]];
21:     interpolation_buffer0=interpolation_buffer1*(coord0-a->legend[0][key0])+interpolation_buffer0*(a->legend[0][key0+1]-coord0);
22: hyper_volume*=(a->legend[0][key0+1]-a->legend[0][key0]);
# /home/ystatter/virunga/VM/commands/lut_interpolation_7.c
12:     int key0=s2o((coord0-a->legend[0][0])*a->physical_factor[0]);
14:     if (key0>=a->size[0]-1) key0=a->size[0]-2;
16:     sizer*=a->size[0];
19:     int key1=s2o((coord1-a->legend[1][0])*a->physical_factor[1]);
21:     if (key1>=a->size[1]-1) key1=a->size[1]-2;
23:     sizer*=a->size[1];
26:     int key2=s2o((coord2-a->legend[2][0])*a->physical_factor[2]);
28:     if (key2>=a->size[2]-1) key2=a->size[2]-2;
30:     sizer*=a->size[2];
33:     int key3=s2o((coord3-a->legend[3][0])*a->physical_factor[3]);
35:     if (key3>=a->size[3]-1) key3=a->size[3]-2;
37:     sizer*=a->size[3];
40:     int key4=s2o((coord4-a->legend[4][0])*a->physical_factor[4]);
42:     if (key4>=a->size[4]-1) key4=a->size[4]-2;
44:     sizer*=a->size[4];
47:     int key5=s2o((coord5-a->legend[5][0])*a->physical_factor[5]);
49:     if (key5>=a->size[5]-1) key5=a->size[5]-2;
51:     sizer*=a->size[5];
54:     int key6=s2o((coord6-a->legend[6][0])*a->physical_factor[6]);
56:     if (key6>=a->size[6]-1) key6=a->size[6]-2;
58:     sizer*=a->size[6];
59:     float interpolation_buffer0=a->content[index+a->neighbors[0]];
60:     float interpolation_buffer1=a->content[index+a->neighbors[1]];
61:     float interpolation_buffer2=a->content[index+a->neighbors[2]];
62:     float interpolation_buffer3=a->content[index+a->neighbors[3]];
63:     float interpolation_buffer4=a->content[index+a->neighbors[4]];
64:     float interpolation_buffer5=a->content[index+a->neighbors[5]];
65:     float interpolation_buffer6=a->content[index+a->neighbors[6]];
66:     float interpolation_buffer7=a->content[index+a->neighbors[7]];
67:     float interpolation_buffer8=a->content[index+a->neighbors[8]];
68:     float interpolation_buffer9=a->content[index+a->neighbors[9]];
69:     float interpolation_buffer10=a->content[index+a->neighbors[10]];
70:     float interpolation_buffer11=a->content[index+a->neighbors[11]];
71:     float interpolation_buffer12=a->content[index+a->neighbors[12]];
72:     float interpolation_buffer13=a->content[index+a->neighbors[13]];
73:     float interpolation_buffer14=a->content[index+a->neighbors[14]];
74:     float interpolation_buffer15=a->content[index+a->neighbors[15]];
75:     float interpolation_buffer16=a->content[index+a->neighbors[16]];
76:     float interpolation_buffer17=a->content[index+a->neighbors[17]];
77:     float interpolation_buffer18=a->content[index+a->neighbors[18]];
78:     float interpolation_buffer19=a->content[index+a->neighbors[19]];
79:     float interpolation_buffer20=a->content[index+a->neighbors[20]];
80:     float interpolation_buffer21=a->content[index+a->neighbors[21]];
81:     float interpolation_buffer22=a->content[index+a->neighbors[22]];
82:     float interpolation_buffer23=a->content[index+a->neighbors[23]];
83:     float interpolation_buffer24=a->content[index+a->neighbors[24]];
84:     float interpolation_buffer25=a->content[index+a->neighbors[25]];
85:     float interpolation_buffer26=a->content[index+a->neighbors[26]];
86:     float interpolation_buffer27=a->content[index+a->neighbors[27]];
87:     float interpolation_buffer28=a->content[index+a->neighbors[28]];
88:     float interpolation_buffer29=a->content[index+a->neighbors[29]];
89:     float interpolation_buffer30=a->content[index+a->neighbors[30]];
90:     float interpolation_buffer31=a->content[index+a->neighbors[31]];
91:     float interpolation_buffer32=a->content[index+a->neighbors[32]];
92:     float interpolation_buffer33=a->content[index+a->neighbors[33]];
93:     float interpolation_buffer34=a->content[index+a->neighbors[34]];
94:     float interpolation_buffer35=a->content[index+a->neighbors[35]];
95:     float interpolation_buffer36=a->content[index+a->neighbors[36]];
96:     float interpolation_buffer37=a->content[index+a->neighbors[37]];
97:     float interpolation_buffer38=a->content[index+a->neighbors[38]];
98:     float interpolation_buffer39=a->content[index+a->neighbors[39]];
99:     float interpolation_buffer40=a->content[index+a->neighbors[40]];
100:     float interpolation_buffer41=a->content[index+a->neighbors[41]];
101:     float interpolation_buffer42=a->content[index+a->neighbors[42]];
102:     float interpolation_buffer43=a->content[index+a->neighbors[43]];
103:     float interpolation_buffer44=a->content[index+a->neighbors[44]];
104:     float interpolation_buffer45=a->content[index+a->neighbors[45]];
105:     float interpolation_buffer46=a->content[index+a->neighbors[46]];
106:     float interpolation_buffer47=a->content[index+a->neighbors[47]];
107:     float interpolation_buffer48=a->content[index+a->neighbors[48]];
108:     float interpolation_buffer49=a->content[index+a->neighbors[49]];
109:     float interpolation_buffer50=a->content[index+a->neighbors[50]];
110:     float interpolation_buffer51=a->content[index+a->neighbors[51]];
111:     float interpolation_buffer52=a->content[index+a->neighbors[52]];
112:     float interpolation_buffer53=a->content[index+a->neighbors[53]];
113:     float interpolation_buffer54=a->content[index+a->neighbors[54]];
114:     float interpolation_buffer55=a->content[index+a->neighbors[55]];
115:     float interpolation_buffer56=a->content[index+a->neighbors[56]];
116:     float interpolation_buffer57=a->content[index+a->neighbors[57]];
117:     float interpolation_buffer58=a->content[index+a->neighbors[58]];
118:     float interpolation_buffer59=a->content[index+a->neighbors[59]];
119:     float interpolation_buffer60=a->content[index+a->neighbors[60]];
120:     float interpolation_buffer61=a->content[index+a->neighbors[61]];
121:     float interpolation_buffer62=a->content[index+a->neighbors[62]];
122:     float interpolation_buffer63=a->content[index+a->neighbors[63]];
123:     float interpolation_buffer64=a->content[index+a->neighbors[64]];
124:     float interpolation_buffer65=a->content[index+a->neighbors[65]];
125:     float interpolation_buffer66=a->content[index+a->neighbors[66]];
126:     float interpolation_buffer67=a->content[index+a->neighbors[67]];
127:     float interpolation_buffer68=a->content[index+a->neighbors[68]];
128:     float interpolation_buffer69=a->content[index+a->neighbors[69]];
129:     float interpolation_buffer70=a->content[index+a->neighbors[70]];
130:     float interpolation_buffer71=a->content[index+a->neighbors[71]];
131:     float interpolation_buffer72=a->content[index+a->neighbors[72]];
132:     float interpolation_buffer73=a->content[index+a->neighbors[73]];
133:     float interpolation_buffer74=a->content[index+a->neighbors[74]];
134:     float interpolation_buffer75=a->content[index+a->neighbors[75]];
135:     float interpolation_buffer76=a->content[index+a->neighbors[76]];
136:     float interpolation_buffer77=a->content[index+a->neighbors[77]];
137:     float interpolation_buffer78=a->content[index+a->neighbors[78]];
138:     float interpolation_buffer79=a->content[index+a->neighbors[79]];
139:     float interpolation_buffer80=a->content[index+a->neighbors[80]];
140:     float interpolation_buffer81=a->content[index+a->neighbors[81]];
141:     float interpolation_buffer82=a->content[index+a->neighbors[82]];
142:     float interpolation_buffer83=a->content[index+a->neighbors[83]];
143:     float interpolation_buffer84=a->content[index+a->neighbors[84]];
144:     float interpolation_buffer85=a->content[index+a->neighbors[85]];
145:     float interpolation_buffer86=a->content[index+a->neighbors[86]];
146:     float interpolation_buffer87=a->content[index+a->neighbors[87]];
147:     float interpolation_buffer88=a->content[index+a->neighbors[88]];
148:     float interpolation_buffer89=a->content[index+a->neighbors[89]];
149:     float interpolation_buffer90=a->content[index+a->neighbors[90]];
150:     float interpolation_buffer91=a->content[index+a->neighbors[91]];
151:     float interpolation_buffer92=a->content[index+a->neighbors[92]];
152:     float interpolation_buffer93=a->content[index+a->neighbors[93]];
153:     float interpolation_buffer94=a->content[index+a->neighbors[94]];
154:     float interpolation_buffer95=a->content[index+a->neighbors[95]];
155:     float interpolation_buffer96=a->content[index+a->neighbors[96]];
156:     float interpolation_buffer97=a->content[index+a->neighbors[97]];
157:     float interpolation_buffer98=a->content[index+a->neighbors[98]];
158:     float interpolation_buffer99=a->content[index+a->neighbors[99]];
159:     float interpolation_buffer100=a->content[index+a->neighbors[100]];
160:     float interpolation_buffer101=a->content[index+a->neighbors[101]];
161:     float interpolation_buffer102=a->content[index+a->neighbors[102]];
162:     float interpolation_buffer103=a->content[index+a->neighbors[103]];
163:     float interpolation_buffer104=a->content[index+a->neighbors[104]];
164:     float interpolation_buffer105=a->content[index+a->neighbors[105]];
165:     float interpolation_buffer106=a->content[index+a->neighbors[106]];
166:     float interpolation_buffer107=a->content[index+a->neighbors[107]];
167:     float interpolation_buffer108=a->content[index+a->neighbors[108]];
168:     float interpolation_buffer109=a->content[index+a->neighbors[109]];
169:     float interpolation_buffer110=a->content[index+a->neighbors[110]];
170:     float interpolation_buffer111=a->content[index+a->neighbors[111]];
171:     float interpolation_buffer112=a->content[index+a->neighbors[112]];
172:     float interpolation_buffer113=a->content[index+a->neighbors[113]];
173:     float interpolation_buffer114=a->content[index+a->neighbors[114]];
174:     float interpolation_buffer115=a->content[index+a->neighbors[115]];
175:     float interpolation_buffer116=a->content[index+a->neighbors[116]];
176:     float interpolation_buffer117=a->content[index+a->neighbors[117]];
177:     float interpolation_buffer118=a->content[index+a->neighbors[118]];
178:     float interpolation_buffer119=a->content[index+a->neighbors[119]];
179:     float interpolation_buffer120=a->content[index+a->neighbors[120]];
180:     float interpolation_buffer121=a->content[index+a->neighbors[121]];
181:     float interpolation_buffer122=a->content[index+a->neighbors[122]];
182:     float interpolation_buffer123=a->content[index+a->neighbors[123]];
183:     float interpolation_buffer124=a->content[index+a->neighbors[124]];
184:     float interpolation_buffer125=a->content[index+a->neighbors[125]];
185:     float interpolation_buffer126=a->content[index+a->neighbors[126]];
186:     float interpolation_buffer127=a->content[index+a->neighbors[127]];
189:     interpolation_buffer0=interpolation_buffer1*(coord0-a->legend[0][key0])+interpolation_buffer0*(a->legend[0][key0+1]-coord0);
190: interpolation_buffer1=interpolation_buffer3*(coord0-a->legend[0][key0])+interpolation_buffer2*(a->legend[0][key0+1]-coord0);
191: interpolation_buffer2=interpolation_buffer5*(coord0-a->legend[0][key0])+interpolation_buffer4*(a->legend[0][key0+1]-coord0);
192: interpolation_buffer3=interpolation_buffer7*(coord0-a->legend[0][key0])+interpolation_buffer6*(a->legend[0][key0+1]-coord0);
193: interpolation_buffer4=interpolation_buffer9*(coord0-a->legend[0][key0])+interpolation_buffer8*(a->legend[0][key0+1]-coord0);
194: interpolation_buffer5=interpolation_buffer11*(coord0-a->legend[0][key0])+interpolation_buffer10*(a->legend[0][key0+1]-coord0);
195: interpolation_buffer6=interpolation_buffer13*(coord0-a->legend[0][key0])+interpolation_buffer12*(a->legend[0][key0+1]-coord0);
196: interpolation_buffer7=interpolation_buffer15*(coord0-a->legend[0][key0])+interpolation_buffer14*(a->legend[0][key0+1]-coord0);
197: interpolation_buffer8=interpolation_buffer17*(coord0-a->legend[0][key0])+interpolation_buffer16*(a->legend[0][key0+1]-coord0);
198: interpolation_buffer9=interpolation_buffer19*(coord0-a->legend[0][key0])+interpolation_buffer18*(a->legend[0][key0+1]-coord0);
199: interpolation_buffer10=interpolation_buffer21*(coord0-a->legend[0][key0])+interpolation_buffer20*(a->legend[0][key0+1]-coord0);
200: interpolation_buffer11=interpolation_buffer23*(coord0-a->legend[0][key0])+interpolation_buffer22*(a->legend[0][key0+1]-coord0);
201: interpolation_buffer12=interpolation_buffer25*(coord0-a->legend[0][key0])+interpolation_buffer24*(a->legend[0][key0+1]-coord0);
202: interpolation_buffer13=interpolation_buffer27*(coord0-a->legend[0][key0])+interpolation_buffer26*(a->legend[0][key0+1]-coord0);
203: interpolation_buffer14=interpolation_buffer29*(coord0-a->legend[0][key0])+interpolation_buffer28*(a->legend[0][key0+1]-coord0);
204: interpolation_buffer15=interpolation_buffer31*(coord0-a->legend[0][key0])+interpolation_buffer30*(a->legend[0][key0+1]-coord0);
205: interpolation_buffer16=interpolation_buffer33*(coord0-a->legend[0][key0])+interpolation_buffer32*(a->legend[0][key0+1]-coord0);
206: interpolation_buffer17=interpolation_buffer35*(coord0-a->legend[0][key0])+interpolation_buffer34*(a->legend[0][key0+1]-coord0);
207: interpolation_buffer18=interpolation_buffer37*(coord0-a->legend[0][key0])+interpolation_buffer36*(a->legend[0][key0+1]-coord0);
208: interpolation_buffer19=interpolation_buffer39*(coord0-a->legend[0][key0])+interpolation_buffer38*(a->legend[0][key0+1]-coord0);
209: interpolation_buffer20=interpolation_buffer41*(coord0-a->legend[0][key0])+interpolation_buffer40*(a->legend[0][key0+1]-coord0);
210: interpolation_buffer21=interpolation_buffer43*(coord0-a->legend[0][key0])+interpolation_buffer42*(a->legend[0][key0+1]-coord0);
211: interpolation_buffer22=interpolation_buffer45*(coord0-a->legend[0][key0])+interpolation_buffer44*(a->legend[0][key0+1]-coord0);
212: interpolation_buffer23=interpolation_buffer47*(coord0-a->legend[0][key0])+interpolation_buffer46*(a->legend[0][key0+1]-coord0);
213: interpolation_buffer24=interpolation_buffer49*(coord0-a->legend[0][key0])+interpolation_buffer48*(a->legend[0][key0+1]-coord0);
214: interpolation_buffer25=interpolation_buffer51*(coord0-a->legend[0][key0])+interpolation_buffer50*(a->legend[0][key0+1]-coord0);
215: interpolation_buffer26=interpolation_buffer53*(coord0-a->legend[0][key0])+interpolation_buffer52*(a->legend[0][key0+1]-coord0);
216: interpolation_buffer27=interpolation_buffer55*(coord0-a->legend[0][key0])+interpolation_buffer54*(a->legend[0][key0+1]-coord0);
217: interpolation_buffer28=interpolation_buffer57*(coord0-a->legend[0][key0])+interpolation_buffer56*(a->legend[0][key0+1]-coord0);
218: interpolation_buffer29=interpolation_buffer59*(coord0-a->legend[0][key0])+interpolation_buffer58*(a->legend[0][key0+1]-coord0);
219: interpolation_buffer30=interpolation_buffer61*(coord0-a->legend[0][key0])+interpolation_buffer60*(a->legend[0][key0+1]-coord0);
220: interpolation_buffer31=interpolation_buffer63*(coord0-a->legend[0][key0])+interpolation_buffer62*(a->legend[0][key0+1]-coord0);
221: interpolation_buffer32=interpolation_buffer65*(coord0-a->legend[0][key0])+interpolation_buffer64*(a->legend[0][key0+1]-coord0);
222: interpolation_buffer33=interpolation_buffer67*(coord0-a->legend[0][key0])+interpolation_buffer66*(a->legend[0][key0+1]-coord0);
223: interpolation_buffer34=interpolation_buffer69*(coord0-a->legend[0][key0])+interpolation_buffer68*(a->legend[0][key0+1]-coord0);
224: interpolation_buffer35=interpolation_buffer71*(coord0-a->legend[0][key0])+interpolation_buffer70*(a->legend[0][key0+1]-coord0);
225: interpolation_buffer36=interpolation_buffer73*(coord0-a->legend[0][key0])+interpolation_buffer72*(a->legend[0][key0+1]-coord0);
226: interpolation_buffer37=interpolation_buffer75*(coord0-a->legend[0][key0])+interpolation_buffer74*(a->legend[0][key0+1]-coord0);
227: interpolation_buffer38=interpolation_buffer77*(coord0-a->legend[0][key0])+interpolation_buffer76*(a->legend[0][key0+1]-coord0);
228: interpolation_buffer39=interpolation_buffer79*(coord0-a->legend[0][key0])+interpolation_buffer78*(a->legend[0][key0+1]-coord0);
229: interpolation_buffer40=interpolation_buffer81*(coord0-a->legend[0][key0])+interpolation_buffer80*(a->legend[0][key0+1]-coord0);
230: interpolation_buffer41=interpolation_buffer83*(coord0-a->legend[0][key0])+interpolation_buffer82*(a->legend[0][key0+1]-coord0);
231: interpolation_buffer42=interpolation_buffer85*(coord0-a->legend[0][key0])+interpolation_buffer84*(a->legend[0][key0+1]-coord0);
232: interpolation_buffer43=interpolation_buffer87*(coord0-a->legend[0][key0])+interpolation_buffer86*(a->legend[0][key0+1]-coord0);
233: interpolation_buffer44=interpolation_buffer89*(coord0-a->legend[0][key0])+interpolation_buffer88*(a->legend[0][key0+1]-coord0);
234: interpolation_buffer45=interpolation_buffer91*(coord0-a->legend[0][key0])+interpolation_buffer90*(a->legend[0][key0+1]-coord0);
235: interpolation_buffer46=interpolation_buffer93*(coord0-a->legend[0][key0])+interpolation_buffer92*(a->legend[0][key0+1]-coord0);
236: interpolation_buffer47=interpolation_buffer95*(coord0-a->legend[0][key0])+interpolation_buffer94*(a->legend[0][key0+1]-coord0);
237: interpolation_buffer48=interpolation_buffer97*(coord0-a->legend[0][key0])+interpolation_buffer96*(a->legend[0][key0+1]-coord0);
238: interpolation_buffer49=interpolation_buffer99*(coord0-a->legend[0][key0])+interpolation_buffer98*(a->legend[0][key0+1]-coord0);
239: interpolation_buffer50=interpolation_buffer101*(coord0-a->legend[0][key0])+interpolation_buffer100*(a->legend[0][key0+1]-coord0);
240: interpolation_buffer51=interpolation_buffer103*(coord0-a->legend[0][key0])+interpolation_buffer102*(a->legend[0][key0+1]-coord0);
241: interpolation_buffer52=interpolation_buffer105*(coord0-a->legend[0][key0])+interpolation_buffer104*(a->legend[0][key0+1]-coord0);
242: interpolation_buffer53=interpolation_buffer107*(coord0-a->legend[0][key0])+interpolation_buffer106*(a->legend[0][key0+1]-coord0);
243: interpolation_buffer54=interpolation_buffer109*(coord0-a->legend[0][key0])+interpolation_buffer108*(a->legend[0][key0+1]-coord0);
244: interpolation_buffer55=interpolation_buffer111*(coord0-a->legend[0][key0])+interpolation_buffer110*(a->legend[0][key0+1]-coord0);
245: interpolation_buffer56=interpolation_buffer113*(coord0-a->legend[0][key0])+interpolation_buffer112*(a->legend[0][key0+1]-coord0);
246: interpolation_buffer57=interpolation_buffer115*(coord0-a->legend[0][key0])+interpolation_buffer114*(a->legend[0][key0+1]-coord0);
247: interpolation_buffer58=interpolation_buffer117*(coord0-a->legend[0][key0])+interpolation_buffer116*(a->legend[0][key0+1]-coord0);
248: interpolation_buffer59=interpolation_buffer119*(coord0-a->legend[0][key0])+interpolation_buffer118*(a->legend[0][key0+1]-coord0);
249: interpolation_buffer60=interpolation_buffer121*(coord0-a->legend[0][key0])+interpolation_buffer120*(a->legend[0][key0+1]-coord0);
250: interpolation_buffer61=interpolation_buffer123*(coord0-a->legend[0][key0])+interpolation_buffer122*(a->legend[0][key0+1]-coord0);
251: interpolation_buffer62=interpolation_buffer125*(coord0-a->legend[0][key0])+interpolation_buffer124*(a->legend[0][key0+1]-coord0);
252: interpolation_buffer63=interpolation_buffer127*(coord0-a->legend[0][key0])+interpolation_buffer126*(a->legend[0][key0+1]-coord0);
253: hyper_volume*=(a->legend[0][key0+1]-a->legend[0][key0]);
254: interpolation_buffer0=interpolation_buffer1*(coord1-a->legend[1][key1])+interpolation_buffer0*(a->legend[1][key1+1]-coord1);
255: interpolation_buffer1=interpolation_buffer3*(coord1-a->legend[1][key1])+interpolation_buffer2*(a->legend[1][key1+1]-coord1);
256: interpolation_buffer2=interpolation_buffer5*(coord1-a->legend[1][key1])+interpolation_buffer4*(a->legend[1][key1+1]-coord1);
257: interpolation_buffer3=interpolation_buffer7*(coord1-a->legend[1][key1])+interpolation_buffer6*(a->legend[1][key1+1]-coord1);
258: interpolation_buffer4=interpolation_buffer9*(coord1-a->legend[1][key1])+interpolation_buffer8*(a->legend[1][key1+1]-coord1);
259: interpolation_buffer5=interpolation_buffer11*(coord1-a->legend[1][key1])+interpolation_buffer10*(a->legend[1][key1+1]-coord1);
260: interpolation_buffer6=interpolation_buffer13*(coord1-a->legend[1][key1])+interpolation_buffer12*(a->legend[1][key1+1]-coord1);
261: interpolation_buffer7=interpolation_buffer15*(coord1-a->legend[1][key1])+interpolation_buffer14*(a->legend[1][key1+1]-coord1);
262: interpolation_buffer8=interpolation_buffer17*(coord1-a->legend[1][key1])+interpolation_buffer16*(a->legend[1][key1+1]-coord1);
263: interpolation_buffer9=interpolation_buffer19*(coord1-a->legend[1][key1])+interpolation_buffer18*(a->legend[1][key1+1]-coord1);
264: interpolation_buffer10=interpolation_buffer21*(coord1-a->legend[1][key1])+interpolation_buffer20*(a->legend[1][key1+1]-coord1);
265: interpolation_buffer11=interpolation_buffer23*(coord1-a->legend[1][key1])+interpolation_buffer22*(a->legend[1][key1+1]-coord1);
266: interpolation_buffer12=interpolation_buffer25*(coord1-a->legend[1][key1])+interpolation_buffer24*(a->legend[1][key1+1]-coord1);
267: interpolation_buffer13=interpolation_buffer27*(coord1-a->legend[1][key1])+interpolation_buffer26*(a->legend[1][key1+1]-coord1);
268: interpolation_buffer14=interpolation_buffer29*(coord1-a->legend[1][key1])+interpolation_buffer28*(a->legend[1][key1+1]-coord1);
269: interpolation_buffer15=interpolation_buffer31*(coord1-a->legend[1][key1])+interpolation_buffer30*(a->legend[1][key1+1]-coord1);
270: interpolation_buffer16=interpolation_buffer33*(coord1-a->legend[1][key1])+interpolation_buffer32*(a->legend[1][key1+1]-coord1);
271: interpolation_buffer17=interpolation_buffer35*(coord1-a->legend[1][key1])+interpolation_buffer34*(a->legend[1][key1+1]-coord1);
272: interpolation_buffer18=interpolation_buffer37*(coord1-a->legend[1][key1])+interpolation_buffer36*(a->legend[1][key1+1]-coord1);
273: interpolation_buffer19=interpolation_buffer39*(coord1-a->legend[1][key1])+interpolation_buffer38*(a->legend[1][key1+1]-coord1);
274: interpolation_buffer20=interpolation_buffer41*(coord1-a->legend[1][key1])+interpolation_buffer40*(a->legend[1][key1+1]-coord1);
275: interpolation_buffer21=interpolation_buffer43*(coord1-a->legend[1][key1])+interpolation_buffer42*(a->legend[1][key1+1]-coord1);
276: interpolation_buffer22=interpolation_buffer45*(coord1-a->legend[1][key1])+interpolation_buffer44*(a->legend[1][key1+1]-coord1);
277: interpolation_buffer23=interpolation_buffer47*(coord1-a->legend[1][key1])+interpolation_buffer46*(a->legend[1][key1+1]-coord1);
278: interpolation_buffer24=interpolation_buffer49*(coord1-a->legend[1][key1])+interpolation_buffer48*(a->legend[1][key1+1]-coord1);
279: interpolation_buffer25=interpolation_buffer51*(coord1-a->legend[1][key1])+interpolation_buffer50*(a->legend[1][key1+1]-coord1);
280: interpolation_buffer26=interpolation_buffer53*(coord1-a->legend[1][key1])+interpolation_buffer52*(a->legend[1][key1+1]-coord1);
281: interpolation_buffer27=interpolation_buffer55*(coord1-a->legend[1][key1])+interpolation_buffer54*(a->legend[1][key1+1]-coord1);
282: interpolation_buffer28=interpolation_buffer57*(coord1-a->legend[1][key1])+interpolation_buffer56*(a->legend[1][key1+1]-coord1);
283: interpolation_buffer29=interpolation_buffer59*(coord1-a->legend[1][key1])+interpolation_buffer58*(a->legend[1][key1+1]-coord1);
284: interpolation_buffer30=interpolation_buffer61*(coord1-a->legend[1][key1])+interpolation_buffer60*(a->legend[1][key1+1]-coord1);
285: interpolation_buffer31=interpolation_buffer63*(coord1-a->legend[1][key1])+interpolation_buffer62*(a->legend[1][key1+1]-coord1);
286: hyper_volume*=(a->legend[1][key1+1]-a->legend[1][key1]);
287: interpolation_buffer0=interpolation_buffer1*(coord2-a->legend[2][key2])+interpolation_buffer0*(a->legend[2][key2+1]-coord2);
288: interpolation_buffer1=interpolation_buffer3*(coord2-a->legend[2][key2])+interpolation_buffer2*(a->legend[2][key2+1]-coord2);
289: interpolation_buffer2=interpolation_buffer5*(coord2-a->legend[2][key2])+interpolation_buffer4*(a->legend[2][key2+1]-coord2);
290: interpolation_buffer3=interpolation_buffer7*(coord2-a->legend[2][key2])+interpolation_buffer6*(a->legend[2][key2+1]-coord2);
291: interpolation_buffer4=interpolation_buffer9*(coord2-a->legend[2][key2])+interpolation_buffer8*(a->legend[2][key2+1]-coord2);
292: interpolation_buffer5=interpolation_buffer11*(coord2-a->legend[2][key2])+interpolation_buffer10*(a->legend[2][key2+1]-coord2);
293: interpolation_buffer6=interpolation_buffer13*(coord2-a->legend[2][key2])+interpolation_buffer12*(a->legend[2][key2+1]-coord2);
294: interpolation_buffer7=interpolation_buffer15*(coord2-a->legend[2][key2])+interpolation_buffer14*(a->legend[2][key2+1]-coord2);
295: interpolation_buffer8=interpolation_buffer17*(coord2-a->legend[2][key2])+interpolation_buffer16*(a->legend[2][key2+1]-coord2);
296: interpolation_buffer9=interpolation_buffer19*(coord2-a->legend[2][key2])+interpolation_buffer18*(a->legend[2][key2+1]-coord2);
297: interpolation_buffer10=interpolation_buffer21*(coord2-a->legend[2][key2])+interpolation_buffer20*(a->legend[2][key2+1]-coord2);
298: interpolation_buffer11=interpolation_buffer23*(coord2-a->legend[2][key2])+interpolation_buffer22*(a->legend[2][key2+1]-coord2);
299: interpolation_buffer12=interpolation_buffer25*(coord2-a->legend[2][key2])+interpolation_buffer24*(a->legend[2][key2+1]-coord2);
300: interpolation_buffer13=interpolation_buffer27*(coord2-a->legend[2][key2])+interpolation_buffer26*(a->legend[2][key2+1]-coord2);
301: interpolation_buffer14=interpolation_buffer29*(coord2-a->legend[2][key2])+interpolation_buffer28*(a->legend[2][key2+1]-coord2);
302: interpolation_buffer15=interpolation_buffer31*(coord2-a->legend[2][key2])+interpolation_buffer30*(a->legend[2][key2+1]-coord2);
303: hyper_volume*=(a->legend[2][key2+1]-a->legend[2][key2]);
304: interpolation_buffer0=interpolation_buffer1*(coord3-a->legend[3][key3])+interpolation_buffer0*(a->legend[3][key3+1]-coord3);
305: interpolation_buffer1=interpolation_buffer3*(coord3-a->legend[3][key3])+interpolation_buffer2*(a->legend[3][key3+1]-coord3);
306: interpolation_buffer2=interpolation_buffer5*(coord3-a->legend[3][key3])+interpolation_buffer4*(a->legend[3][key3+1]-coord3);
307: interpolation_buffer3=interpolation_buffer7*(coord3-a->legend[3][key3])+interpolation_buffer6*(a->legend[3][key3+1]-coord3);
308: interpolation_buffer4=interpolation_buffer9*(coord3-a->legend[3][key3])+interpolation_buffer8*(a->legend[3][key3+1]-coord3);
309: interpolation_buffer5=interpolation_buffer11*(coord3-a->legend[3][key3])+interpolation_buffer10*(a->legend[3][key3+1]-coord3);
310: interpolation_buffer6=interpolation_buffer13*(coord3-a->legend[3][key3])+interpolation_buffer12*(a->legend[3][key3+1]-coord3);
311: interpolation_buffer7=interpolation_buffer15*(coord3-a->legend[3][key3])+interpolation_buffer14*(a->legend[3][key3+1]-coord3);
312: hyper_volume*=(a->legend[3][key3+1]-a->legend[3][key3]);
313: interpolation_buffer0=interpolation_buffer1*(coord4-a->legend[4][key4])+interpolation_buffer0*(a->legend[4][key4+1]-coord4);
314: interpolation_buffer1=interpolation_buffer3*(coord4-a->legend[4][key4])+interpolation_buffer2*(a->legend[4][key4+1]-coord4);
315: interpolation_buffer2=interpolation_buffer5*(coord4-a->legend[4][key4])+interpolation_buffer4*(a->legend[4][key4+1]-coord4);
316: interpolation_buffer3=interpolation_buffer7*(coord4-a->legend[4][key4])+interpolation_buffer6*(a->legend[4][key4+1]-coord4);
317: hyper_volume*=(a->legend[4][key4+1]-a->legend[4][key4]);
318: interpolation_buffer0=interpolation_buffer1*(coord5-a->legend[5][key5])+interpolation_buffer0*(a->legend[5][key5+1]-coord5);
319: interpolation_buffer1=interpolation_buffer3*(coord5-a->legend[5][key5])+interpolation_buffer2*(a->legend[5][key5+1]-coord5);
320: hyper_volume*=(a->legend[5][key5+1]-a->legend[5][key5]);
321: interpolation_buffer0=interpolation_buffer1*(coord6-a->legend[6][key6])+interpolation_buffer0*(a->legend[6][key6+1]-coord6);
322: hyper_volume*=(a->legend[6][key6+1]-a->legend[6][key6]);
# /home/ystatter/virunga/VM/commands/lut_interpolation_5.c
12:     int key0=s2o((coord0-a->legend[0][0])*a->physical_factor[0]);
14:     if (key0>=a->size[0]-1) key0=a->size[0]-2;
16:     sizer*=a->size[0];
19:     int key1=s2o((coord1-a->legend[1][0])*a->physical_factor[1]);
21:     if (key1>=a->size[1]-1) key1=a->size[1]-2;
23:     sizer*=a->size[1];
26:     int key2=s2o((coord2-a->legend[2][0])*a->physical_factor[2]);
28:     if (key2>=a->size[2]-1) key2=a->size[2]-2;
30:     sizer*=a->size[2];
33:     int key3=s2o((coord3-a->legend[3][0])*a->physical_factor[3]);
35:     if (key3>=a->size[3]-1) key3=a->size[3]-2;
37:     sizer*=a->size[3];
40:     int key4=s2o((coord4-a->legend[4][0])*a->physical_factor[4]);
42:     if (key4>=a->size[4]-1) key4=a->size[4]-2;
44:     sizer*=a->size[4];
45:     float interpolation_buffer0=a->content[index+a->neighbors[0]];
46:     float interpolation_buffer1=a->content[index+a->neighbors[1]];
47:     float interpolation_buffer2=a->content[index+a->neighbors[2]];
48:     float interpolation_buffer3=a->content[index+a->neighbors[3]];
49:     float interpolation_buffer4=a->content[index+a->neighbors[4]];
50:     float interpolation_buffer5=a->content[index+a->neighbors[5]];
51:     float interpolation_buffer6=a->content[index+a->neighbors[6]];
52:     float interpolation_buffer7=a->content[index+a->neighbors[7]];
53:     float interpolation_buffer8=a->content[index+a->neighbors[8]];
54:     float interpolation_buffer9=a->content[index+a->neighbors[9]];
55:     float interpolation_buffer10=a->content[index+a->neighbors[10]];
56:     float interpolation_buffer11=a->content[index+a->neighbors[11]];
57:     float interpolation_buffer12=a->content[index+a->neighbors[12]];
58:     float interpolation_buffer13=a->content[index+a->neighbors[13]];
59:     float interpolation_buffer14=a->content[index+a->neighbors[14]];
60:     float interpolation_buffer15=a->content[index+a->neighbors[15]];
61:     float interpolation_buffer16=a->content[index+a->neighbors[16]];
62:     float interpolation_buffer17=a->content[index+a->neighbors[17]];
63:     float interpolation_buffer18=a->content[index+a->neighbors[18]];
64:     float interpolation_buffer19=a->content[index+a->neighbors[19]];
65:     float interpolation_buffer20=a->content[index+a->neighbors[20]];
66:     float interpolation_buffer21=a->content[index+a->neighbors[21]];
67:     float interpolation_buffer22=a->content[index+a->neighbors[22]];
68:     float interpolation_buffer23=a->content[index+a->neighbors[23]];
69:     float interpolation_buffer24=a->content[index+a->neighbors[24]];
70:     float interpolation_buffer25=a->content[index+a->neighbors[25]];
71:     float interpolation_buffer26=a->content[index+a->neighbors[26]];
72:     float interpolation_buffer27=a->content[index+a->neighbors[27]];
73:     float interpolation_buffer28=a->content[index+a->neighbors[28]];
74:     float interpolation_buffer29=a->content[index+a->neighbors[29]];
75:     float interpolation_buffer30=a->content[index+a->neighbors[30]];
76:     float interpolation_buffer31=a->content[index+a->neighbors[31]];
79:     interpolation_buffer0=interpolation_buffer1*(coord0-a->legend[0][key0])+interpolation_buffer0*(a->legend[0][key0+1]-coord0);
80: interpolation_buffer1=interpolation_buffer3*(coord0-a->legend[0][key0])+interpolation_buffer2*(a->legend[0][key0+1]-coord0);
81: interpolation_buffer2=interpolation_buffer5*(coord0-a->legend[0][key0])+interpolation_buffer4*(a->legend[0][key0+1]-coord0);
82: interpolation_buffer3=interpolation_buffer7*(coord0-a->legend[0][key0])+interpolation_buffer6*(a->legend[0][key0+1]-coord0);
83: interpolation_buffer4=interpolation_buffer9*(coord0-a->legend[0][key0])+interpolation_buffer8*(a->legend[0][key0+1]-coord0);
84: interpolation_buffer5=interpolation_buffer11*(coord0-a->legend[0][key0])+interpolation_buffer10*(a->legend[0][key0+1]-coord0);
85: interpolation_buffer6=interpolation_buffer13*(coord0-a->legend[0][key0])+interpolation_buffer12*(a->legend[0][key0+1]-coord0);
86: interpolation_buffer7=interpolation_buffer15*(coord0-a->legend[0][key0])+interpolation_buffer14*(a->legend[0][key0+1]-coord0);
87: interpolation_buffer8=interpolation_buffer17*(coord0-a->legend[0][key0])+interpolation_buffer16*(a->legend[0][key0+1]-coord0);
88: interpolation_buffer9=interpolation_buffer19*(coord0-a->legend[0][key0])+interpolation_buffer18*(a->legend[0][key0+1]-coord0);
89: interpolation_buffer10=interpolation_buffer21*(coord0-a->legend[0][key0])+interpolation_buffer20*(a->legend[0][key0+1]-coord0);
90: interpolation_buffer11=interpolation_buffer23*(coord0-a->legend[0][key0])+interpolation_buffer22*(a->legend[0][key0+1]-coord0);
91: interpolation_buffer12=interpolation_buffer25*(coord0-a->legend[0][key0])+interpolation_buffer24*(a->legend[0][key0+1]-coord0);
92: interpolation_buffer13=interpolation_buffer27*(coord0-a->legend[0][key0])+interpolation_buffer26*(a->legend[0][key0+1]-coord0);
93: interpolation_buffer14=interpolation_buffer29*(coord0-a->legend[0][key0])+interpolation_buffer28*(a->legend[0][key0+1]-coord0);
94: interpolation_buffer15=interpolation_buffer31*(coord0-a->legend[0][key0])+interpolation_buffer30*(a->legend[0][key0+1]-coord0);
95: hyper_volume*=(a->legend[0][key0+1]-a->legend[0][key0]);
96: interpolation_buffer0=interpolation_buffer1*(coord1-a->legend[1][key1])+interpolation_buffer0*(a->legend[1][key1+1]-coord1);
97: interpolation_buffer1=interpolation_buffer3*(coord1-a->legend[1][key1])+interpolation_buffer2*(a->legend[1][key1+1]-coord1);
98: interpolation_buffer2=interpolation_buffer5*(coord1-a->legend[1][key1])+interpolation_buffer4*(a->legend[1][key1+1]-coord1);
99: interpolation_buffer3=interpolation_buffer7*(coord1-a->legend[1][key1])+interpolation_buffer6*(a->legend[1][key1+1]-coord1);
100: interpolation_buffer4=interpolation_buffer9*(coord1-a->legend[1][key1])+interpolation_buffer8*(a->legend[1][key1+1]-coord1);
101: interpolation_buffer5=interpolation_buffer11*(coord1-a->legend[1][key1])+interpolation_buffer10*(a->legend[1][key1+1]-coord1);
102: interpolation_buffer6=interpolation_buffer13*(coord1-a->legend[1][key1])+interpolation_buffer12*(a->legend[1][key1+1]-coord1);
103: interpolation_buffer7=interpolation_buffer15*(coord1-a->legend[1][key1])+interpolation_buffer14*(a->legend[1][key1+1]-coord1);
104: hyper_volume*=(a->legend[1][key1+1]-a->legend[1][key1]);
105: interpolation_buffer0=interpolation_buffer1*(coord2-a->legend[2][key2])+interpolation_buffer0*(a->legend[2][key2+1]-coord2);
106: interpolation_buffer1=interpolation_buffer3*(coord2-a->legend[2][key2])+interpolation_buffer2*(a->legend[2][key2+1]-coord2);
107: interpolation_buffer2=interpolation_buffer5*(coord2-a->legend[2][key2])+interpolation_buffer4*(a->legend[2][key2+1]-coord2);
108: interpolation_buffer3=interpolation_buffer7*(coord2-a->legend[2][key2])+interpolation_buffer6*(a->legend[2][key2+1]-coord2);
109: hyper_volume*=(a->legend[2][key2+1]-a->legend[2][key2]);
110: interpolation_buffer0=interpolation_buffer1*(coord3-a->legend[3][key3])+interpolation_buffer0*(a->legend[3][key3+1]-coord3);
111: interpolation_buffer1=interpolation_buffer3*(coord3-a->legend[3][key3])+interpolation_buffer2*(a->legend[3][key3+1]-coord3);
112: hyper_volume*=(a->legend[3][key3+1]-a->legend[3][key3]);
113: interpolation_buffer0=interpolation_buffer1*(coord4-a->legend[4][key4])+interpolation_buffer0*(a->legend[4][key4+1]-coord4);
114: hyper_volume*=(a->legend[4][key4+1]-a->legend[4][key4]);
# /home/ystatter/virunga/LUT/look_up_table.c
17:     a->content[index]=nt_scalar.s;
22:     linear_interpolation_table *L=a->LIT;
31:     ordinal step=a->neighbors[reversed_dim];
33:     for (i=0;i<reversed_dim;i++) step*=a->size[i];
38:     for (i=0;i<a->dim;i++) {
40:         float scaled_coord=(coord[j++]-a->legend[i][0])/(a->legend[i][1]-a->legend[i][0]);
47:         index+=key[i]*a->neighbors[i];
49:     float target=coord[a->dim-1];
50:     for (i=0;i<a->size[reversed_dim]-1;i++) {
51:         if ((a->content[index+i*step]<=target)&&(a->content[index+i*step+step]>=target)) {
61:     num_of_corners=1<<a->dim;
66:         right_interpolation_buffer[right_corner_counter++]=a->content[index+a->neighbors[corner]];
68:         left_interpolation_buffer[left_corner_counter++]=a->content[index+a->neighbors[corner]];
90:         for (corner=0;i<num_of_corners;i++) if (!(corner&(1<<reversed_dim))) left_interpolation_buffer[left_corner_counter++]=a->content[index+a->neighbors[corner]];
107:         for (corner=0;i<num_of_corners;i++) if (corner&(1<<reversed_dim)) right_interpolation_buffer[right_corner_counter++]=a->content[index+a->neighbors[corner]];
120:     float left_coord=a->legend[reversed_dim][key[reversed_dim]];
121:     float right_coord=a->legend[reversed_dim][key[reversed_dim]+1];
129:         linear_interpolation_table *L=a->LIT;
140:         if ((a->hit)&&(hit_enabled)) {
145:                 cell_top[$i]=a->legend[$i][a->size[$i]-1];
146:                 cell_bottom[$i]=a->legend[$i][0];
317:             end=a->size[$i]-1;
318:             if (a->legend[$i][end]>a->legend[$i][0]) {
319:                 if (coord[$i]<=a->legend[$i][0]) {
321:                     // #Warning: "Undershoot %g<%g" coord[$i] a->legend[$i][0]
322:                 } else if (coord[$i]>=a->legend[$i][end]) {
324:                     // #Warning: "Overshoot %g>%g" coord[$i] a->legend[$i][end]
330:                         if (coord[$i]>=a->legend[$i][mid]) {
339:                 if (coord[$i]>=a->legend[$i][0]) {
341:                     // #Warning: "Undershoot %g>%g" coord[$i] a->legend[$i][0]
342:                 } else if (coord[$i]<=a->legend[$i][end]) {
344:                     // #Warning: "Overshoot %g<%g" coord[$i] a->legend[$i][end]
350:                         if (coord[$i]<=a->legend[$i][mid]) {
361:             sizer*=a->size[$i];
362:             lit_sizer*=(a->size[$i]-1);
380:             float interpolation_buffer$corner=a->content[index+a->neighbors[$corner]];
387:             weight=(coord[$weighing_dim]-a->legend[$weighing_dim][key[$weighing_dim]])/(a->legend[$weighing_dim][key[$weighing_dim]+1]-a->legend[$weighing_dim][key[$weighing_dim]]);
409:    //     linear_interpolation_table *L=a->LIT;
420:             end=a->size[$i]-1;
421:             if (a->legend[$i][end]>a->legend[$i][0]) {
422:                 if (coord[$i]<=a->legend[$i][0]) {
424:                     // #Warning: "Undershoot %g<%g" coord[$i] a->legend[$i][0]
425:                 } else if (coord[$i]>=a->legend[$i][end]) {
427:                     // #Warning: "Overshoot %g>%g" coord[$i] a->legend[$i][end]
433:                         if (coord[$i]>=a->legend[$i][mid]) {
442:                 if (coord[$i]>=a->legend[$i][0]) {
444:                     // #Warning: "Undershoot %g>%g" coord[$i] a->legend[$i][0]
445:                 } else if (coord[$i]<=a->legend[$i][end]) {
447:                     // #Warning: "Overshoot %g<%g" coord[$i] a->legend[$i][end]
453:                         if (coord[$i]<=a->legend[$i][mid]) {
464:             sizer*=a->size[$i];
465:             lit_sizer*=(a->size[$i]-1);
469: 	    #Info: "coord$i=%g base=%g factor=%g" coord[$i] a->legend[$i][0] a->physical_factor[$i]
470: 	    int key${i}=s2o((coord[$i]-a->legend[$i][0])*a->physical_factor[$i]);
472: 	    if (key${i}>=a->size[$i]-1) key${i}=a->size[$i]-2;
473: //	    #Info: "key$i=%d/%d    %d" key${i} a->size[$i]  a->sizer[$i]
474:             index+=key${i}*a->sizer[$i];
476: //            sizer*=a->size[$i];
477: //            lit_sizer*=(a->size[$i]-1);
497: 	float *hypercube=&(a->content[index]);
499:             float interpolation_buffer$corner=hypercube[a->neighbors[$corner]];
506: 	    w1=coord[$weighing_dim]-a->legend[$weighing_dim][key${weighing_dim}];
507: 	    w2=a->legend[$weighing_dim][key${weighing_dim}+1]-coord[$weighing_dim];
518:         retval=interpolation_buffer0/a->hypercube_volume;
549:         linear_interpolation_table *L=a->LIT;
561:             end=a->size[$i]-1;
562:             if (a->legend[$i][end]>a->legend[$i][0]) {
563:                 if (coord[$i]<=a->legend[$i][0]) {
565:                     // #Warning: "Undershoot %g<%g" coord[$i] a->legend[$i][0]
566:                 } else if (coord[$i]>=a->legend[$i][end]) {
568:                     // #Warning: "Overshoot %g>%g" coord[$i] a->legend[$i][end]
574:                         if (coord[$i]>=a->legend[$i][mid]) {
583:                 if (coord[$i]>=a->legend[$i][0]) {
585:                     // #Warning: "Undershoot %g>%g" coord[$i] a->legend[$i][0]
586:                 } else if (coord[$i]<=a->legend[$i][end]) {
588:                     // #Warning: "Overshoot %g<%g" coord[$i] a->legend[$i][end]
594:                         if (coord[$i]<=a->legend[$i][mid]) {
605:             sizer*=a->size[$i];
606:             lit_sizer*=(a->size[$i]-1);
607:             (*i_cluster)->lower_margin[$i]=a->legend[$i][key[$i]];
608:             (*i_cluster)->upper_margin[$i]=a->legend[$i][key[$i]+1];
613:             float interpolation_buffer$corner=a->content[index+a->neighbors[$corner]];
621:             weight=(coord[$weighing_dim]-a->legend[$weighing_dim][key[$weighing_dim]]);
622: 	    hyper_volume*=(a->legend[$weighing_dim][key[$weighing_dim]+1]-a->legend[$weighing_dim][key[$weighing_dim]]);
644:     ordinal index=i_index*(a->dim+1);
647:     for (i=a->dim-1;i>=0;i--) {
655:     for (i=0;i<a->dim;i++) {
657:         sizer*=a->size[i];
663:     for (i=0;i<a->dim;i++) {
666:         midpoint[i]=(a->legend[i][key[i]]+a->legend[i][key[i]+1])/2;
671:     num_of_corners=1<<a->dim;
673:         ordinal corner_index=array_index+a->neighbors[corner];
674:         float corner_value=a->content[corner_index];
678:         for (i=0;i<a->dim;i++) {
691:     for (i=0;i<a->dim;i++) {
694:         slopes[i]=slopes[i]/(a->legend[i][key[i]+1]-a->legend[i][key[i]]);
699:     slopes[a->dim]=constant;
707:         float interpolated_value=slopes[a->dim];
709:         for (i=0;i<a->dim;i++) {
710:             interpolated_value+=slopes[i]*a->legend[i][key[i]+(tmp_corner&1)];
713:         float original_value=a->content[array_index+a->neighbors[corner]];
726:     slopes[a->dim]=sob.s;
727:     slopes[a->dim]=0;
734:     a->LIT=L;
735:     L->dim=a->dim;
742:     for (i=0;i<a->dim;i++) {
744:         ordinal tmp=a->size[i];
750:         L->volume*=(a->size[i]-1);
751:         L->baseline[i]=a->legend[i][0];
752:         L->inv_step[i]=1/(a->legend[i][1]-a->legend[i][0]);
754:     ordinal num_of_corners=1<<a->dim;
756:     a->neighbors=(ordinal *)malloc(sizeof(ordinal)*num_of_corners);
762:         for (i=0;i<a->dim;i++) {
764:             sizer*=a->size[i];
768:         a->neighbors[offset]=index;
770:     L->content=(float *)malloc(sizeof(scalar)*(1+a->dim)*L->volume);
# /home/ystatter/virunga/LUT/look_up_table.vm.tcl
12:         append body "    int key${i}=s2o((coord$i-a->legend[$i][0])*a->physical_factor[$i]);\n"
14:         append body "    if (key${i}>=a->size[$i]-1) key${i}=a->size[$i]-2;\n"
16:         append body "    sizer*=a->size[$i];\n"
19:         append body "    float interpolation_buffer$corner=a->content\[index+a->neighbors\[$corner\]\];\n"
29:             append body "interpolation_buffer$j=interpolation_buffer$k*(coord$weighing_dim-a->legend[$weighing_dim][key${weighing_dim}])+interpolation_buffer$i*(a->legend[$weighing_dim][key${weighing_dim}+1]-coord$weighing_dim);\n"
32:         append body "hyper_volume*=(a->legend[$weighing_dim][key${weighing_dim}+1]-a->legend[$weighing_dim][key${weighing_dim}]);\n"
# /home/ystatter/virunga/frontend/numparam/xpressn.c
1734:     pscopy(tstr_p, s, ia-1, i - ia);
# /home/ystatter/virunga/frontend/resolution/solver.tcl
43:     regsub -all {\$([a-z])} $value {$::solver::\1} value
58:     while {[regexp {\$([a-zA-Z][a-zA-Z_0-9]*)} $buf -> varname]} {
# /home/ystatter/virunga/frontend/parser/complete.c
151:         for (a = pmatches->wl_next; a; a = a->wl_next)
152:             if (a->wl_word[i] != wbuf[j]) {
# /home/ystatter/virunga/frontend/help/provide.c
117:             for (pa = parent->parent->children; pa->next; pa = pa->next)
118:                 if (pa->next == parent)
120:             if (!pa->next)
122:             pa->next = pa->next->next;
# /home/ystatter/virunga/frontend/outitf.c
394:     data->name = copy(name);
395:     data->type = type;
396:     data->gtype = GRID_LIN;
397:     data->regular = TRUE;
398:     data->outIndex = ind;
425:     data->name = copy(name);
431:     data->specName = unique;
433:     data->specParamName = copy(param);
435:     data->specIndex = depind;
436:     data->specType = -1;
437:     data->specFast = NULL;
438:     data->regular = FALSE;
# /home/ystatter/virunga/frontend/com_alias.c
143:             ta->al_prev = al;
# /home/ystatter/virunga/ciderlib/twod/twoelect.c
31:     return ARG_MIN(a->id, b->id, 0);
# /home/ystatter/virunga/BerkeleyDB.6.0/include/db.h
220: /* Key/data structure -- a Data-Base Thang. */
# /home/ystatter/virunga/spicelib/analysis/ninteg.c
33:     exponent = (lnNdens - lnNlstDens) / data->delLnFreq;
35: 	return (noizDens * data->delFreq);
37: 	a = limexp(lnNdens - exponent*data->lnFreq);
40: 	    return (a * (data->lnFreq - data->lnLastFreq));
42: 	    return (a * ((exp(exponent * data->lnFreq) - exp(exponent * data->lnLastFreq)) /
# /home/ystatter/virunga/spicelib/analysis/cktdest.c
186:             state = state_data->head[i];
195:         tfree(state_data->head);
196:         tfree(state_data->tail);
197:         tfree(state_data->last_step);
198:         tfree(state_data->free);
200:         tfree(state_data->modified);
201:         tfree(state_data->modified_index);
202:         tfree(state_data->total_size);
204:         tfree(state_data->desc);
211:             node = node_data->head[i];
218:         tfree(node_data->head);
219:         tfree(node_data->tail);
220:         tfree(node_data->last_step);
221:         tfree(node_data->free);
223:         tfree(node_data->modified);
224:         tfree(node_data->modified_index);
227:             rhs = &(node_data->rhs[i]);
236:         tfree(node_data->rhs);
238:             rhs = &(node_data->rhsold[i]);
247:         tfree(node_data->rhsold);
248:         tfree(node_data->total_load);
255:             msg = msg_data->head[i];
263:         tfree(msg_data->head);
264:         tfree(msg_data->tail);
265:         tfree(msg_data->last_step);
266:         tfree(msg_data->free);
268:         tfree(msg_data->modified);
269:         tfree(msg_data->modified_index);
# /home/ystatter/virunga/spicelib/analysis/cktnoise.c
59: 	    data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
61: 	    SPfrontEnd->IFnewUid (ckt, &(data->namelist[data->numPlots++]),
64: 	    data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
66: 	    SPfrontEnd->IFnewUid (ckt, &(data->namelist[data->numPlots++]),
71: 	    data->outpVector =
72: 		TMALLOC(scalar, data->numPlots);
77: 	    data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
78: 	    SPfrontEnd->IFnewUid (ckt, &(data->namelist[data->numPlots++]),
81: 	    data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
82: 	    SPfrontEnd->IFnewUid (ckt, &(data->namelist[data->numPlots++]),
86: 	    data->outpVector =
87: 		TMALLOC(scalar, data->numPlots);
102: 		|| data->prtSummary)
104: 		data->outpVector[data->outNumber++] = outNdens;
105: 		data->outpVector[data->outNumber++] =
106: 		    (outNdens * data->GainSqInv);
108: 		refVal.rValue = data->freq; /* the reference is the freq */
109: 		outData.v.numValue = data->outNumber; /* vector number */
110: 		outData.v.vec.rVec = data->outpVector; /* vector of outputs */
111: 		SPfrontEnd->OUTpData (data->NplotPtr, &refVal, &outData);
116: 	    data->outpVector[data->outNumber++] =  data->outNoiz; 
117: 	    data->outpVector[data->outNumber++] =  data->inNoise;
118: 	    outData.v.vec.rVec = data->outpVector; /* vector of outputs */
119: 	    outData.v.numValue = data->outNumber; /* vector number */
120: 	    SPfrontEnd->OUTpData (data->NplotPtr, &refVal, &outData);
129: 	SPfrontEnd->OUTendPlot (data->NplotPtr);
130: 	FREE(data->namelist);
131: 	FREE(data->outpVector);
139:     if (data->outpVector) 
140:     for (f=0;f<data->outNumber;f++) {
141:         #Info: "%d ... %e" f data->outpVector[f]
# /home/ystatter/virunga/spicelib/analysis/noisean.c
41:      data->freq = 1;
42:      data->outNoiz = 0.0;
43:      data->inNoise = 0.0;
44:      data->numPlots = 0;
45:      data->lstFreq=1;
46:  	data->delFreq = data->freq - data->lstFreq;
47: 	data->lnFreq = log(MAX(data->freq,N_MINLOG));
48: 	data->lnLastFreq = log(MAX(data->lstFreq,N_MINLOG));
49:         data->delLnFreq = data->lnFreq - data->lnLastFreq;
141: 	data->freq = job->NstartFreq;
142: 	data->outNoiz = 0.0;
143: 	data->inNoise = 0.0;
150: 	data->numPlots = 0;                /* we don't have any plots  yet */
162:                                            data->numPlots, data->namelist, IF_REAL,
163:                                            &(data->NplotPtr));
167: 	    SPfrontEnd->OUTattributes (data->NplotPtr, NULL, OUT_SCALE_LOG, NULL);
176: 	    data->freq = job->NstartFreq * exp (step *
181: 	    data->freq = job->NstartFreq + step *
191: 	data->outNoiz = job->NsavOnoise;
192: 	data->inNoise = job->NsavInoise;
198:                                            &(data->NplotPtr));
215:     data->lstFreq = data->freq;
219:     while (data->freq <= job->NstopFreq + freqTol) {
222: 	    job->NsavOnoise = data->outNoiz; /* up until now     */
223: 	    job->NsavInoise = data->inNoise;
226: 	ckt->CKTomega = 2.0 * M_PI * data->freq;
239: 	data->GainSqInv = 1.0 / MAX(((realVal*realVal)
241: 	data->lnGainInv = log(data->GainSqInv);
247: 	data->delFreq = data->freq - data->lstFreq;
248: 	data->lnFreq = log(MAX(data->freq,N_MINLOG));
249: 	data->lnLastFreq = log(MAX(data->lstFreq,N_MINLOG));
250:         data->delLnFreq = data->lnFreq - data->lnLastFreq;
253: 	    data->prtSummary = TRUE;
255: 	    data->prtSummary = FALSE;
259: 	data->outNumber = 1;       
262: 	data->outNumber = 0;
275: 	data->lstFreq = data->freq;
283: 	    data->freq *= job->NfreqDelta;
287: 	    data->freq += job->NfreqDelta;
299:     data->numPlots = 0;
300:     data->outNumber = 0;
310:                                    data->numPlots, data->namelist, IF_REAL,
311:                                    &(data->NplotPtr));
# /home/ystatter/virunga/spicelib/analysis/cktpzstr.c
1043:     diff_mag = a->mag_def - b->mag_def;
1051: 	C_SUBEQ(diff_frac, mult * a->f_def, b->f_def);
# /home/ystatter/virunga/spicelib/devices/bsim1/b1noi.c
68:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
69:                             if (!data->namelist) return(E_NOMEM);
71:                             &(data->namelist[data->numPlots++]),
84:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
85:                             if (!data->namelist) return(E_NOMEM);
87:                             &(data->namelist[data->numPlots++]),
95:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
96:                             if (!data->namelist) return(E_NOMEM);
98:                             &(data->namelist[data->numPlots++]),
132:                     (data->freq *
148:                     if (data->delFreq == 0.0) { 
159:                         if (data->freq == job->NstartFreq) {
165:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
170:                                 tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
171:                                 lnNdens[i] + data->lnGainInv,
172:                                 inst->B1nVar[LNLSTDENS][i] + data->lnGainInv,
175:                                 data->outNoiz += tempOnoise;
176:                                 data->inNoise += tempInoise;
186:                     if (data->prtSummary) {
188:                             data->outpVector[data->outNumber++] = noizDens[i];
196:                             data->outpVector[data->outNumber++] = inst->B1nVar[OUTNOIZ][i];
197:                             data->outpVector[data->outNumber++] = inst->B1nVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/bsimsoi/b4soinoi.c
171:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
172:                             if (!data->namelist)
175:                             &(data->namelist[data->numPlots++]),
186:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
187:                             if (!data->namelist)
190:                             &(data->namelist[data->numPlots++]),
198:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
199:                             if (!data->namelist)
202:                             &(data->namelist[data->numPlots++]),
433:                             / (pow(data->freq, model->B4SOIef)
442:                             / (pow(data->freq, model->B4SOIef)
457:                         data->freq, here->B4SOITempSH);
460:                         data->freq, ckt->CKTtemp); /*v4.2 implementing SH temp */
472:                         * pow(data->freq, model->B4SOIef)
546:                     if (data->delFreq == 0.0)
560:                         if (data->freq ==
569:                     {   /* data->delFreq != 0.0,
579:                                 * data->GainSqInv, lnNdens[i]
580:                                 + data->lnGainInv,
582:                                 + data->lnGainInv, data);
585:                                 data->outNoiz += tempOnoise;
586:                                 data->inNoise += tempInoise;
601:                     if (data->prtSummary)
604:                             data->outpVector[data->outNumber++]
613:                         {    data->outpVector[data->outNumber++]
615:                             data->outpVector[data->outNumber++]
# /home/ystatter/virunga/spicelib/devices/bsim4v5/b4v5noi.c
144:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
145:                             if (!data->namelist)
148:                             &(data->namelist[data->numPlots++]),
159:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
160:                             if (!data->namelist)
163:                             &(data->namelist[data->numPlots++]),
171:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
172:                             if (!data->namelist)
175:                             &(data->namelist[data->numPlots++]),
383:                         / (pow(data->freq, model->BSIM4v5ef)
394:                         data->freq, ckt->CKTtemp);
398:                         * pow(data->freq, model->BSIM4v5ef) * 1.0e10
452:                     if (data->delFreq == 0.0)
466:                         if (data->freq ==
475:                     {   /* data->delFreq != 0.0,
485:                                 * data->GainSqInv, lnNdens[i]
486:                                 + data->lnGainInv,
488:                                 + data->lnGainInv, data);
491:                                 data->outNoiz += tempOnoise;
492:                                 data->inNoise += tempInoise;
506:                     if (data->prtSummary)
509:                             data->outpVector[data->outNumber++]
518:                         {    data->outpVector[data->outNumber++]
520:                             data->outpVector[data->outNumber++]
# /home/ystatter/virunga/spicelib/devices/cap/capdefs.h
31:     double CAPdtemp;    /* delta-temperature of this instance */
# /home/ystatter/virunga/spicelib/devices/mes/mesload.c
361:                 + 0.5 * (qgga-qggb + qggc-qggd);
363:                 + 0.5 * (qgga-qggc + qggb-qggd);
# /home/ystatter/virunga/spicelib/devices/mes/mesnoise.c
68:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
69:                             if (!data->namelist) return(E_NOMEM);
71:                             &(data->namelist[data->numPlots++]),
84:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
85:                             if (!data->namelist) return(E_NOMEM);
87:                             &(data->namelist[data->numPlots++]),
96:                             data->numPlots += 2; 
99:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
100:                             if (!data->namelist) return(E_NOMEM);
102:                             &(data->namelist[data->numPlots++]),
136:                     data->freq;
149:                     if (data->delFreq == 0.0) { 
160:                         if (data->freq == job->NstartFreq) {
166:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
171:                                 tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
172:                                 lnNdens[i] + data->lnGainInv,
173:                                 inst->MESnVar[LNLSTDENS][i] + data->lnGainInv,
176:                                 data->outNoiz += tempOnoise;
177:                                 data->inNoise += tempInoise;
187:                     if (data->prtSummary) {
189:                             data->outpVector[data->outNumber++] = noizDens[i];
197:                             data->outpVector[data->outNumber++] = inst->MESnVar[OUTNOIZ][i];
198:                             data->outpVector[data->outNumber++] = inst->MESnVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/bsim3v1/b3v1noi.c
145:                             data->namelist = TREALLOC(
146:                             IFuid, data->namelist, 
147:                             data->numPlots + 1);
148:                             if (!data->namelist)
151:                             &(data->namelist[data->numPlots++]),
162:                             data->namelist = TREALLOC(
163:                             IFuid, data->namelist, 
164:                             data->numPlots + 1);
165:                             if (!data->namelist)
168:                             &(data->namelist[data->numPlots++]),
176:                             data->namelist = TREALLOC(
177:                             IFuid, data->namelist, 
178:                             data->numPlots + 1);
179:                             if (!data->namelist)
182:                             &(data->namelist[data->numPlots++]),
238:                         / (pow(data->freq, model->BSIM3v1ef)
253:                             vds, model, here, data->freq,
263:                             * pow(data->freq, model->BSIM3v1ef)
269:                             here, data->freq, ckt->CKTtemp);
292:                     if (data->delFreq == 0.0)
306:                         if (data->freq ==
315:                     {   /* data->delFreq != 0.0,
325:                                 * data->GainSqInv, lnNdens[i]
326:                                 + data->lnGainInv,
328:                                 + data->lnGainInv, data);
331:                                 data->outNoiz += tempOnoise;
332:                                 data->inNoise += tempInoise;
346:                     if (data->prtSummary)
349:                             data->outpVector[data->outNumber++]
358:                         {    data->outpVector[data->outNumber++]
360:                             data->outpVector[data->outNumber++]
# /home/ystatter/virunga/spicelib/devices/hisimhv1/hsmhvnoi.c
83:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
84:                             if (!data->namelist)
87:                             (ckt, &(data->namelist[data->numPlots++]),
95:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
96:                             if (!data->namelist)
99:                             (ckt, &(data->namelist[data->numPlots++]),
104:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
105:                             if (!data->namelist)
108:                             (ckt, &(data->namelist[data->numPlots++]),
168:                         noizDens[HSMHVFLNOIZ] *= here->HSMHV_noiflick / pow(data->freq, model->HSMHV_falph) ; 
181:                         noizDens[HSMHVIGNOIZ] *= here->HSMHV_noiigate * here->HSMHV_noicross * here->HSMHV_noicross * data->freq * data->freq;
193:                     if ( data->delFreq == 0.0 ) {
205:                         if (data->freq == ((NOISEAN*) ckt->CKTcurJob)->NstartFreq) {
213:                         /* data->delFreq != 0.0,
222:                                 Nintegrate(noizDens[i] * data->GainSqInv, 
223:                                 lnNdens[i] + data->lnGainInv,
224:                                 here->HSMHVnVar[LNLSTDENS][i] + data->lnGainInv,
227:                                 data->outNoiz += tempOnoise;
228:                                 data->inNoise += tempInoise;
238:                     if ( data->prtSummary ) {
241:                             data->outpVector[data->outNumber++] = noizDens[i];
249:                             data->outpVector[data->outNumber++] = here->HSMHVnVar[OUTNOIZ][i];
250:                             data->outpVector[data->outNumber++] = here->HSMHVnVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/hisimhv1/hsmhveval.c
81: Mitiko Miura-Mattausch, Professor, Hiroshima University
6459:                                 /* derivatives of channel current w.r.t. external bias (only due to Ra-dependencies!) */
# /home/ystatter/virunga/spicelib/devices/hisimhv1/hsmhveval_qover.h
325:         Ps0_iniB_dVxb = Chi_B_dVxb/beta- Vxbgmtcl_dVxbgmt;
349:     Ps0LD_dVxb = Chi_dVxb/beta- Vxbgmtcl_dVxbgmt;
# /home/ystatter/virunga/spicelib/devices/bsim3v0/b3v0noi.c
122:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
123:                             if (!data->namelist)
126:                             &(data->namelist[data->numPlots++]),
137:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
138:                             if (!data->namelist)
141:                             &(data->namelist[data->numPlots++]),
149:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
150:                             if (!data->namelist)
153:                             &(data->namelist[data->numPlots++]),
206:                             model, here, data->freq,
215:                             * pow(data->freq, model->BSIM3v0ef)
222:                             data->freq, ckt->CKTtemp);
236:                         / (pow(data->freq, model->BSIM3v0ef)
254:                     if (data->delFreq == 0.0)
268:                         if (data->freq ==
277:                     {   /* data->delFreq != 0.0,
287:                                 * data->GainSqInv, lnNdens[i]
288:                                 + data->lnGainInv,
290:                                 + data->lnGainInv, data);
293:                                 data->outNoiz += tempOnoise;
294:                                 data->inNoise += tempInoise;
308:                     if (data->prtSummary)
311:                             data->outpVector[data->outNumber++]
320:                         {    data->outpVector[data->outNumber++]
322:                             data->outpVector[data->outNumber++]
# /home/ystatter/virunga/spicelib/devices/res/resnoise.c
80:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
81:                             if (!data->namelist) return(E_NOMEM);
83:                             &(data->namelist[data->numPlots++]),
95:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
96:                             if (!data->namelist) return(E_NOMEM);
98:                             &(data->namelist[data->numPlots++]),
107:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
108:                             if (!data->namelist) return(E_NOMEM);
110:                             &(data->namelist[data->numPlots++]),
139:                     N_MINLOG))) / data->freq;
147:                     if (data->delFreq == 0.0) { 
158:                         if (data->freq == job->NstartFreq) {
164:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
173:                                 data->GainSqInv ,lnNdens[i] 
174:                                 + data->lnGainInv,
176:                                 + data->lnGainInv,
179:                                 data->outNoiz += tempOutNoise;
180:                                 data->inNoise += tempInNoise;                         
191:                     if (data->prtSummary) {
193:                             data->outpVector[data->outNumber++] = noizDens[i];
201:                             data->outpVector[data->outNumber++] = inst->RESnVar[OUTNOIZ][i];
202:                             data->outpVector[data->outNumber++] = inst->RESnVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/res/resdefs.h
32:     double RESdtemp;    /* delta-temperature of a particular instance  */
60:     unsigned RESdtempGiven  : 1;    /* indicates delta-temp specified  */
# /home/ystatter/virunga/spicelib/devices/jfet/jfetnoi.c
68:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
69:                             if (!data->namelist) return(E_NOMEM);
71:                             &(data->namelist[data->numPlots++]),
82:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
83:                             if (!data->namelist) return(E_NOMEM);
85:                             &(data->namelist[data->numPlots++]),
91:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
92:                             if (!data->namelist) return(E_NOMEM);
94:                             &(data->namelist[data->numPlots++]),
144:                     data->freq;
157:                     if (data->delFreq == 0.0) {
168:                         if (data->freq == job->NstartFreq) {
174:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
179:                                 tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
180:                                 lnNdens[i] + data->lnGainInv,
181:                                 inst->JFETnVar[LNLSTDENS][i] + data->lnGainInv,
184:                                 data->outNoiz += tempOnoise;
185:                                 data->inNoise += tempInoise;
195:                     if (data->prtSummary) {
197:                             data->outpVector[data->outNumber++] = noizDens[i];
205:                             data->outpVector[data->outNumber++] = inst->JFETnVar[OUTNOIZ][i];
206:                             data->outpVector[data->outNumber++] = inst->JFETnVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/vbic/vbicnoise.c
83:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
84:                             if (!data->namelist) return(E_NOMEM);
86:                             &(data->namelist[data->numPlots++]),
97:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
98:                             if (!data->namelist) return(E_NOMEM);
100:                             &(data->namelist[data->numPlots++]),
107:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
108:                             if (!data->namelist) return(E_NOMEM);
110:                             &(data->namelist[data->numPlots++]),
175:                     pow(data->freq, model->VBICfNexpB);
185:                     pow(data->freq, model->VBICfNexpB);
207:                     if (data->delFreq == 0.0) { 
218:                         if (data->freq == job->NstartFreq) {
224:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
232:                                 tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
233:                                 lnNdens[i] + data->lnGainInv,
234:                                 inst->VBICnVar[LNLSTDENS][i] + data->lnGainInv,
237:                                 data->outNoiz += tempOnoise;
238:                                 data->inNoise += tempInoise;
248:                     if (data->prtSummary) {
250:                             data->outpVector[data->outNumber++] = noizDens[i];
258:                             data->outpVector[data->outNumber++] = inst->VBICnVar[OUTNOIZ][i];
259:                             data->outpVector[data->outNumber++] = inst->VBICnVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/mos9/mos9load.c
696:                     dvsdvg = dvsdga-(1.0-vdsc/argb)*vdsc*dfgdvg*onfg;
733:                     else dfddvd = -dfgdvd*arga-fd2*onvdsc;
# /home/ystatter/virunga/spicelib/devices/mos9/mos9noi.c
69:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
70:                             if (!data->namelist) return(E_NOMEM);
72:                             &(data->namelist[data->numPlots++]),
85:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
86:                             if (!data->namelist) return(E_NOMEM);
88:                             &(data->namelist[data->numPlots++]),
96:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
97:                             if (!data->namelist) return(E_NOMEM);
99:                             &(data->namelist[data->numPlots++]),
133:                     (data->freq *
150:                     if (data->delFreq == 0.0) { 
161:                         if (data->freq == job->NstartFreq) {
167:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
172:                                 tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
173:                                 lnNdens[i] + data->lnGainInv,
174:                                 inst->MOS9nVar[LNLSTDENS][i] + data->lnGainInv,
177:                                 data->outNoiz += tempOnoise;
178:                                 data->inNoise += tempInoise;
188:                     if (data->prtSummary) {
190:                             data->outpVector[data->outNumber++] = noizDens[i];
198:                             data->outpVector[data->outNumber++] = inst->MOS9nVar[OUTNOIZ][i];
199:                             data->outpVector[data->outNumber++] = inst->MOS9nVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/jfet2/psmodel.c
152:                             double a_aa = aa-vsat;
289:         QGS_NOW = QGS_BEFORE + 0.5 * (qgga-qggb + qggc-qggd);
290:         QGD_NOW = QGD_BEFORE + 0.5 * (qgga-qggc + qggb-qggd);
# /home/ystatter/virunga/spicelib/devices/jfet2/jfet2noi.c
73:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
74:                             if (!data->namelist) return(E_NOMEM);
76:                             &(data->namelist[data->numPlots++]),
89:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
90:                             if (!data->namelist) return(E_NOMEM);
92:                             &(data->namelist[data->numPlots++]),
100:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
101:                             if (!data->namelist) return(E_NOMEM);
103:                             &(data->namelist[data->numPlots++]),
137:                     data->freq;
150:                     if (data->delFreq == 0.0) { 
161:                         if (data->freq == job->NstartFreq) {
167:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
172:                                 tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
173:                                 lnNdens[i] + data->lnGainInv,
174:                                 inst->JFET2nVar[LNLSTDENS][i] + data->lnGainInv,
177:                                 data->outNoiz += tempOnoise;
178:                                 data->inNoise += tempInoise;
188:                     if (data->prtSummary) {
190:                             data->outpVector[data->outNumber++] = noizDens[i];
198:                             data->outpVector[data->outNumber++] = inst->JFET2nVar[OUTNOIZ][i];
199:                             data->outpVector[data->outNumber++] = inst->JFET2nVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/bsim4v4/b4v4noi.c
171:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
172:                             if (!data->namelist)
175:                             &(data->namelist[data->numPlots++]),
186:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
187:                             if (!data->namelist)
190:                             &(data->namelist[data->numPlots++]),
198:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
199:                             if (!data->namelist)
202:                             &(data->namelist[data->numPlots++]),
383:                         / (pow(data->freq, model->BSIM4v4ef)
394:                         data->freq, ckt->CKTtemp);
398:                         * pow(data->freq, model->BSIM4v4ef) * 1.0e10
467:                     if (data->delFreq == 0.0)
481:                         if (data->freq ==
490:                     {   /* data->delFreq != 0.0,
500:                                 * data->GainSqInv, lnNdens[i]
501:                                 + data->lnGainInv,
503:                                 + data->lnGainInv, data);
506:                                 data->outNoiz += tempOnoise;
507:                                 data->inNoise += tempInoise;
521:                     if (data->prtSummary)
524:                             data->outpVector[data->outNumber++]
533:                         {    data->outpVector[data->outNumber++]
535:                             data->outpVector[data->outNumber++]
# /home/ystatter/virunga/spicelib/devices/soi3/soi3nois.c
92:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
93:                             if (!data->namelist) return(E_NOMEM);
95:                             &(data->namelist[data->numPlots++]),
108:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
109:                             if (!data->namelist) return(E_NOMEM);
111:                             &(data->namelist[data->numPlots++]),
118:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
119:                             if (!data->namelist) return(E_NOMEM);
121:                             &(data->namelist[data->numPlots++]),
178:                         log(MAX(fabs(data->freq),N_MINLOG)))
186:                         (data->freq * EffectiveLength * inst->SOI3w * inst->SOI3m *
195:                         (data->freq * EffectiveLength * EffectiveLength *
215:                     if (data->delFreq == 0.0) { 
226:                         if (data->freq == job->NstartFreq) {
232:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
237:                                 tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
238:                                 lnNdens[i] + data->lnGainInv,
239:                                 inst->SOI3nVar[LNLSTDENS][i] + data->lnGainInv,
242:                                 data->outNoiz += tempOnoise;
243:                                 data->inNoise += tempInoise;
253:                     if (data->prtSummary) {
255:                             data->outpVector[data->outNumber++] = noizDens[i];
263:                             data->outpVector[data->outNumber++] = inst->SOI3nVar[OUTNOIZ][i];
264:                             data->outpVector[data->outNumber++] = inst->SOI3nVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/soi3/soi3load.c
1440:                 (sigma-0.5*(Dpsi_sL_Dvdb + Dpsi_s0_Dvdb)) + 
1445:                 (-sigma-0.5*(Dpsi_sL_Dvsb + Dpsi_s0_Dvsb)) +
# /home/ystatter/virunga/spicelib/devices/mos1/mos1noi.c
79:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
80:                             if (!data->namelist) return(E_NOMEM);
82:                             &(data->namelist[data->numPlots++]),
95:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
96:                             if (!data->namelist) return(E_NOMEM);
98:                             &(data->namelist[data->numPlots++]),
106:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
107:                             if (!data->namelist) return(E_NOMEM);
109:                             &(data->namelist[data->numPlots++]),
142:                     (data->freq * inst->MOS1w * 
157:                     if (data->delFreq == 0.0) { 
168:                         if (data->freq == job->NstartFreq) {
174:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
179:                                 tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
180:                                 lnNdens[i] + data->lnGainInv,
181:                                 inst->MOS1nVar[LNLSTDENS][i] + data->lnGainInv,
184:                                 data->outNoiz += tempOnoise;
185:                                 data->inNoise += tempInoise;
195:                     if (data->prtSummary) {
197:                             data->outpVector[data->outNumber++] = noizDens[i];
205:                             data->outpVector[data->outNumber++] = inst->MOS1nVar[OUTNOIZ][i];
206:                             data->outpVector[data->outNumber++] = inst->MOS1nVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/bsim3soi_pd/b3soipdnoi.c
153:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
154:                             if (!data->namelist)
157:                             &(data->namelist[data->numPlots++]),
168:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
169:                             if (!data->namelist)
172:                             &(data->namelist[data->numPlots++]),
180:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
181:                             if (!data->namelist)
184:                             &(data->namelist[data->numPlots++]),
246:                         / (pow(data->freq, model->B3SOIPDef)
261:                             vds, model, here, data->freq,
271:                             * pow(data->freq, model->B3SOIPDef)
277:                             here, data->freq, ckt->CKTtemp);
307:                     if (data->delFreq == 0.0)
321:                         if (data->freq ==
330:                     {   /* data->delFreq != 0.0,
340:                                 * data->GainSqInv, lnNdens[i]
341:                                 + data->lnGainInv,
343:                                 + data->lnGainInv, data);
346:                                 data->outNoiz += tempOnoise;
347:                                 data->inNoise += tempInoise;
361:                     if (data->prtSummary)
364:                             data->outpVector[data->outNumber++]
373:                         {    data->outpVector[data->outNumber++]
375:                             data->outpVector[data->outNumber++]
# /home/ystatter/virunga/spicelib/devices/asrc/asrcdefs.h
31:     double ASRCdtemp;    /* delta-temperature of a particular instance  */
41:     unsigned ASRCdtempGiven  : 1;    /* indicates delta-temp specified  */
# /home/ystatter/virunga/spicelib/devices/sw/swnoise.c
58:                         data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
59:                         if (!data->namelist) return(E_NOMEM);
61:                         &(data->namelist[data->numPlots++]),
72:                         data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
73:                         if (!data->namelist) return(E_NOMEM);
75:                         &(data->namelist[data->numPlots++]),
83:                         data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
84:                         if (!data->namelist) return(E_NOMEM);
86:                         &(data->namelist[data->numPlots++]),
107:                     if (data->delFreq == 0.0) { 
116:                         if (data->freq == job->NstartFreq) {
119:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
123:                         data->GainSqInv ,lnNdens + data->lnGainInv,
124:                         inst->SWnVar[LNLSTDENS] + data->lnGainInv,
128:                         data->outNoiz += tempOutNoise;
129:                         data->inNoise += tempInNoise;
132:                     if (data->prtSummary) {
133:                         data->outpVector[data->outNumber++] = noizDens;
139:                         data->outpVector[data->outNumber++] = inst->SWnVar[OUTNOIZ];
140:                         data->outpVector[data->outNumber++] = inst->SWnVar[INNOIZ];
# /home/ystatter/virunga/spicelib/devices/cpl/cplsetup.c
1600:     d = (3.0*(a*a-b*b)+2.0*p1*a+p2)*(3.0*(a*a-b*b)+2.0*p1*a+p2);
1602:     n = -(q1*(a*a-b*b)+q2*a+q3)*(6.0*a*b+2.0*p1*b);
1603:     n += (2.0*q1*a*b+q2*b)*(3.0*(a*a-b*b)+2.0*p1*a+p2);
1605:     n = (3.0*(a*a-b*b)+2.0*p1*a+p2)*(q1*(a*a-b*b)+q2*a+q3);
# /home/ystatter/virunga/spicelib/devices/mos3/mos3noi.c
69:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
70:                             if (!data->namelist) return(E_NOMEM);
72:                             &(data->namelist[data->numPlots++]),
85:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
86:                             if (!data->namelist) return(E_NOMEM);
88:                             &(data->namelist[data->numPlots++]),
96:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
97:                             if (!data->namelist) return(E_NOMEM);
99:                             &(data->namelist[data->numPlots++]),
133:                     (data->freq *
149:                     if (data->delFreq == 0.0) { 
160:                         if (data->freq == job->NstartFreq) {
166:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
171:                                 tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
172:                                 lnNdens[i] + data->lnGainInv,
173:                                 inst->MOS3nVar[LNLSTDENS][i] + data->lnGainInv,
176:                                 data->outNoiz += tempOnoise;
177:                                 data->inNoise += tempInoise;
187:                     if (data->prtSummary) {
189:                             data->outpVector[data->outNumber++] = noizDens[i];
197:                             data->outpVector[data->outNumber++] = inst->MOS3nVar[OUTNOIZ][i];
198:                             data->outpVector[data->outNumber++] = inst->MOS3nVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/mos3/mos3load.c
677:                     dvsdvg = dvsdga-(1.0-vdsc/argb)*vdsc*dfgdvg*onfg;
714:                     else dfddvd = -dfgdvd*arga-fd2*onvdsc;
# /home/ystatter/virunga/spicelib/devices/hisim2/hsm2noi.c
89:                             data->namelist = 
90:                             (IFuid *) trealloc((char *) data->namelist,
91:                             ((long unsigned int)data->numPlots + 1) * sizeof(IFuid));
92:                             if (!data->namelist)
95:                             (ckt, &(data->namelist[data->numPlots++]),
103:                             data->namelist = 
104:                             (IFuid *) trealloc((char *) data->namelist,
105:                             ((long unsigned int)data->numPlots + 1) * sizeof(IFuid));
106:                             if (!data->namelist)
109:                             (ckt, &(data->namelist[data->numPlots++]),
114:                             data->namelist = 
115:                             (IFuid *) trealloc((char *) data->namelist,
116:                             ((long unsigned int)data->numPlots + 1) * sizeof(IFuid));
117:                             if (!data->namelist)
120:                             (ckt, &(data->namelist[data->numPlots++]),
202:                         noizDens[HSM2FLNOIZ] *= here->HSM2_noiflick / pow(data->freq, model->HSM2_falph) ;
249:                     /*              data->freq,noizDens[HSM2TOTNOIZ],noizDens[HSM2RDNOIZ],noizDens[HSM2RSNOIZ],noizDens[HSM2FLNOIZ],noizDens[HSM2IDNOIZ],noizDens[HSM2IGNOIZ]); */
253:                     if ( data->delFreq == 0.0 ) {
265:                         if (data->freq == ((NOISEAN*) ckt->CKTcurJob)->NstartFreq) {
273:                         /* data->delFreq != 0.0,
282:                                 Nintegrate(noizDens[i] * data->GainSqInv, 
283:                                 lnNdens[i] + data->lnGainInv,
284:                                 here->HSM2nVar[LNLSTDENS][i] + data->lnGainInv,
287:                                 data->outNoiz += tempOnoise;
288:                                 data->inNoise += tempInoise;
298:                     if ( data->prtSummary ) {
301:                             data->outpVector[data->outNumber++] = noizDens[i];
309:                             data->outpVector[data->outNumber++] = here->HSM2nVar[OUTNOIZ][i];
310:                             data->outpVector[data->outNumber++] = here->HSM2nVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/hisim2/hsm2eval.c
5636:                         Ps0_iniB_dVxb = Chi_B_dVxb/beta- Vxbgmtcl_dVxbgmt;
5657:                     Ps0LD_dVxb = Chi_dVxb/beta- Vxbgmtcl_dVxbgmt;
# /home/ystatter/virunga/spicelib/devices/bsim4/b4noi.c
155:                             data->namelist = TREALLOC(IFuid,
156:                             data->namelist,
157:                             data->numPlots + 1);
158:                             if (!data->namelist)
161:                             &(data->namelist[data->numPlots++]),
171:                             data->namelist = TREALLOC(IFuid,
172:                             data->namelist,
173:                             data->numPlots + 1);
174:                             if (!data->namelist)
177:                             &(data->namelist[data->numPlots++]),
184:                             data->namelist = TREALLOC(IFuid,
185:                             data->namelist,
186:                             data->numPlots + 1);
187:                             if (!data->namelist)
190:                             &(data->namelist[data->numPlots++]),
459:                         omega = 2.0 * M_PI * data->freq;
496:                         / (pow(data->freq, model->BSIM4ef)
507:                         data->freq, ckt->CKTtemp);
511:                         * pow(data->freq, model->BSIM4ef) * 1.0e10
565:                     if (data->delFreq == 0.0)
579:                         if (data->freq ==
588:                     {   /* data->delFreq != 0.0,
598:                                 * data->GainSqInv, lnNdens[i]
599:                                 + data->lnGainInv,
601:                                 + data->lnGainInv, data);
604:                                 data->outNoiz += tempOnoise;
605:                                 data->inNoise += tempInoise;
619:                     if (data->prtSummary)
622:                             data->outpVector[data->outNumber++]
631:                         {    data->outpVector[data->outNumber++]
633:                             data->outpVector[data->outNumber++]
# /home/ystatter/virunga/spicelib/devices/bsim2/b2noi.c
68:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
69:                             if (!data->namelist) return(E_NOMEM);
71:                             &(data->namelist[data->numPlots++]),
84:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
85:                             if (!data->namelist) return(E_NOMEM);
87:                             &(data->namelist[data->numPlots++]),
95:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
96:                             if (!data->namelist) return(E_NOMEM);
98:                             &(data->namelist[data->numPlots++]),
132:                     (data->freq *
148:                     if (data->delFreq == 0.0) { 
159:                         if (data->freq == job->NstartFreq) {
165:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
170:                                 tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
171:                                 lnNdens[i] + data->lnGainInv,
172:                                 inst->B2nVar[LNLSTDENS][i] + data->lnGainInv,
175:                                 data->outNoiz += tempOnoise;
176:                                 data->inNoise += tempInoise;
186:                     if (data->prtSummary) {
188:                             data->outpVector[data->outNumber++] = noizDens[i];
196:                             data->outpVector[data->outNumber++] = inst->B2nVar[OUTNOIZ][i];
197:                             data->outpVector[data->outNumber++] = inst->B2nVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/bsim3soi_dd/b3soiddnoi.c
149:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
150:                             if (!data->namelist)
153:                             &(data->namelist[data->numPlots++]),
164:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
165:                             if (!data->namelist)
168:                             &(data->namelist[data->numPlots++]),
176:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
177:                             if (!data->namelist)
180:                             &(data->namelist[data->numPlots++]),
236:                         / (pow(data->freq, model->B3SOIDDef)
251:                             vds, model, here, data->freq,
261:                             * pow(data->freq, model->B3SOIDDef)
267:                             here, data->freq, ckt->CKTtemp);
298:                     if (data->delFreq == 0.0)
312:                         if (data->freq ==
321:                     {   /* data->delFreq != 0.0,
331:                                 * data->GainSqInv, lnNdens[i]
332:                                 + data->lnGainInv,
334:                                 + data->lnGainInv, data);
337:                                 data->outNoiz += tempOnoise;
338:                                 data->inNoise += tempInoise;
352:                     if (data->prtSummary)
355:                             data->outpVector[data->outNumber++]
364:                         {    data->outpVector[data->outNumber++]
366:                             data->outpVector[data->outNumber++]
# /home/ystatter/virunga/spicelib/devices/bsim4v6/b4v6noi.c
141:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
142:                             if (!data->namelist)
145:                             &(data->namelist[data->numPlots++]),
156:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
157:                             if (!data->namelist)
160:                             &(data->namelist[data->numPlots++]),
168:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
169:                             if (!data->namelist)
172:                             &(data->namelist[data->numPlots++]),
393:                         / (pow(data->freq, model->BSIM4v6ef)
404:                         data->freq, ckt->CKTtemp);
408:                         * pow(data->freq, model->BSIM4v6ef) * 1.0e10
462:                     if (data->delFreq == 0.0)
476:                         if (data->freq ==
485:                     {   /* data->delFreq != 0.0,
495:                                 * data->GainSqInv, lnNdens[i]
496:                                 + data->lnGainInv,
498:                                 + data->lnGainInv, data);
501:                                 data->outNoiz += tempOnoise;
502:                                 data->inNoise += tempInoise;
516:                     if (data->prtSummary)
519:                             data->outpVector[data->outNumber++]
528:                         {    data->outpVector[data->outNumber++]
530:                             data->outpVector[data->outNumber++]
# /home/ystatter/virunga/spicelib/devices/bsim3soi_fd/b3soifdnoi.c
149:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
150:                             if (!data->namelist)
153:                             &(data->namelist[data->numPlots++]),
164:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
165:                             if (!data->namelist)
168:                             &(data->namelist[data->numPlots++]),
176:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
177:                             if (!data->namelist)
180:                             &(data->namelist[data->numPlots++]),
237:                         / (pow(data->freq, model->B3SOIFDef)
252:                             vds, model, here, data->freq,
262:                             * pow(data->freq, model->B3SOIFDef)
268:                             here, data->freq, ckt->CKTtemp);
295:                     if (data->delFreq == 0.0)
309:                         if (data->freq ==
318:                     {   /* data->delFreq != 0.0,
328:                                 * data->GainSqInv, lnNdens[i]
329:                                 + data->lnGainInv,
331:                                 + data->lnGainInv, data);
334:                                 data->outNoiz += tempOnoise;
335:                                 data->inNoise += tempInoise;
349:                     if (data->prtSummary)
352:                             data->outpVector[data->outNumber++]
361:                         {    data->outpVector[data->outNumber++]
363:                             data->outpVector[data->outNumber++]
# /home/ystatter/virunga/spicelib/devices/csw/cswnoise.c
58:                         data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
59:                         if (!data->namelist) return(E_NOMEM);
61:                         &(data->namelist[data->numPlots++]),
70:                         data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
71:                         if (!data->namelist) return(E_NOMEM);
73:                         &(data->namelist[data->numPlots++]),
80:                         data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
81:                         if (!data->namelist) return(E_NOMEM);
83:                         &(data->namelist[data->numPlots++]),
103:                     if (data->delFreq == 0.0) { 
112:                         if (data->freq == job->NstartFreq) {
115:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
119:                         data->GainSqInv ,lnNdens + data->lnGainInv,
120:                         inst->CSWnVar[LNLSTDENS] + data->lnGainInv,
124:                         data->outNoiz += tempOutNoise;
125:                         data->inNoise += tempInNoise;
128:                     if (data->prtSummary) {
129:                         data->outpVector[data->outNumber++] = noizDens;
135:                         data->outpVector[data->outNumber++] = inst->CSWnVar[OUTNOIZ];
136:                         data->outpVector[data->outNumber++] = inst->CSWnVar[INNOIZ];
# /home/ystatter/virunga/spicelib/devices/bsim3v32/b3v32noi.c
231:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
232:                             if (!data->namelist)
235:                             &(data->namelist[data->numPlots++]),
246:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
247:                             if (!data->namelist)
250:                             &(data->namelist[data->numPlots++]),
258:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
259:                             if (!data->namelist)
262:                             &(data->namelist[data->numPlots++]),
335:                         / (pow(data->freq, model->BSIM3v32ef)
352:                             here, data->freq, ckt->CKTtemp);
357:                             * pow(data->freq, model->BSIM3v32ef)
372:                                 here, data->freq, ckt->CKTtemp);
382:                                 * pow (data->freq, model->BSIM3v32ef)
388:                                 here, data->freq, ckt->CKTtemp);
411:                     if (data->delFreq == 0.0)
425:                         if (data->freq ==
434:                     {   /* data->delFreq != 0.0,
445:                                 * data->GainSqInv, lnNdens[i]
446:                                 + data->lnGainInv,
448:                                 + data->lnGainInv, data);
451:                                 data->outNoiz += tempOnoise;
452:                                 data->inNoise += tempInoise;
466:                     if (data->prtSummary)
469:                             data->outpVector[data->outNumber++]
478:                         {    data->outpVector[data->outNumber++]
480:                             data->outpVector[data->outNumber++]
# /home/ystatter/virunga/spicelib/devices/bsim3/b3noi.c
164:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
165:                             if (!data->namelist)
168:                             &(data->namelist[data->numPlots++]),
179:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
180:                             if (!data->namelist)
183:                             &(data->namelist[data->numPlots++]),
191:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
192:                             if (!data->namelist)
195:                             &(data->namelist[data->numPlots++]),
267:                         / (pow(data->freq, model->BSIM3ef)
280:                         here, data->freq, ckt->CKTtemp);
285:                         * pow(data->freq, model->BSIM3ef)
309:                     if (data->delFreq == 0.0)
323:                         if (data->freq ==
332:                     {   /* data->delFreq != 0.0,
342:                                 * data->GainSqInv, lnNdens[i]
343:                                 + data->lnGainInv,
345:                                 + data->lnGainInv, data);
348:                                 data->outNoiz += tempOnoise;
349:                                 data->inNoise += tempInoise;
363:                     if (data->prtSummary)
366:                             data->outpVector[data->outNumber++]
375:                         {    data->outpVector[data->outNumber++]
377:                             data->outpVector[data->outNumber++]
# /home/ystatter/virunga/spicelib/devices/bjt/bjtnoise.c
75:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
76:                             if (!data->namelist) return(E_NOMEM);
78:                             &(data->namelist[data->numPlots++]),
89:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
90:                             if (!data->namelist) return(E_NOMEM);
92:                             &(data->namelist[data->numPlots++]),
99:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
100:                             if (!data->namelist) return(E_NOMEM);
102:                             &(data->namelist[data->numPlots++]),
141:                     data->freq;
156:                     if (data->delFreq == 0.0) { 
167:                         if (data->freq == job->NstartFreq) {
173:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
181:                                 tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
182:                                 lnNdens[i] + data->lnGainInv,
183:                                 inst->BJTnVar[LNLSTDENS][i] + data->lnGainInv,
186:                                 data->outNoiz += tempOnoise;
187:                                 data->inNoise += tempInoise;
197:                     if (data->prtSummary) {
199:                             data->outpVector[data->outNumber++] = noizDens[i];
207:                             data->outpVector[data->outNumber++] = inst->BJTnVar[OUTNOIZ][i];
208:                             data->outpVector[data->outNumber++] = inst->BJTnVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/bjt/bjtload.c
175:             rbpi=here->BJTtbaseResist/here->BJTarea-rbpr;
# /home/ystatter/virunga/spicelib/devices/dio/dioload.c
33:     double csat;    /* area-scaled saturation current */
51:     double gspr;    /* area-scaled conductance */
# /home/ystatter/virunga/spicelib/devices/dio/diodset.c
31:     double csat;    /* area-scaled saturation current */
# /home/ystatter/virunga/spicelib/devices/dio/dionoise.c
68:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
69:                             if (!data->namelist) return(E_NOMEM);
70:                             SPfrontEnd->IFnewUid (ckt, &(data->namelist[data->numPlots++]),
81:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
82:                             if (!data->namelist) return(E_NOMEM);
83:                             SPfrontEnd->IFnewUid (ckt, &(data->namelist[data->numPlots++]),
89:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
90:                             if (!data->namelist) return(E_NOMEM);
91:                             SPfrontEnd->IFnewUid (ckt, &(data->namelist[data->numPlots++]),
118:                     data->freq * inst->DIOm;
130:                     if (data->delFreq == 0.0) { 
141:                         if (data->freq == job->NstartFreq) {
147:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
155:                                 tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
156:                                 lnNdens[i] + data->lnGainInv,
157:                                 inst->DIOnVar[LNLSTDENS][i] + data->lnGainInv,
160:                                 data->outNoiz += tempOnoise;
161:                                 data->inNoise += tempInoise;
171:                     if (data->prtSummary) {
173:                             data->outpVector[data->outNumber++] = noizDens[i];
181:                             data->outpVector[data->outNumber++] = inst->DIOnVar[OUTNOIZ][i];
182:                             data->outpVector[data->outNumber++] = inst->DIOnVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/txl/txlsetup.c
718:     d = (3.0*(a*a-b*b)+2.0*ep1*a+ep2)*(3.0*(a*a-b*b)+2.0*ep1*a+ep2);
720:     n = -(eq1*(a*a-b*b)+eq2*a+eq3)*(6.0*a*b+2.0*ep1*b);
721:     n += (2.0*eq1*a*b+eq2*b)*(3.0*(a*a-b*b)+2.0*ep1*a+ep2);
723:     n = (3.0*(a*a-b*b)+2.0*ep1*a+ep2)*(eq1*(a*a-b*b)+eq2*a+eq3);
# /home/ystatter/virunga/spicelib/devices/mos2/mos2noi.c
69:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
70:                             if (!data->namelist) return(E_NOMEM);
72:                             &(data->namelist[data->numPlots++]),
85:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
86:                             if (!data->namelist) return(E_NOMEM);
88:                             &(data->namelist[data->numPlots++]),
96:                             data->namelist = TREALLOC(IFuid, data->namelist, data->numPlots + 1);
97:                             if (!data->namelist) return(E_NOMEM);
99:                             &(data->namelist[data->numPlots++]),
132:                     (data->freq * inst->MOS2w *
148:                     if (data->delFreq == 0.0) { 
159:                         if (data->freq == job->NstartFreq) {
165:                     } else {   /* data->delFreq != 0.0 (we have to integrate) */
170:                                 tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
171:                                 lnNdens[i] + data->lnGainInv,
172:                                 inst->MOS2nVar[LNLSTDENS][i] + data->lnGainInv,
175:                                 data->outNoiz += tempOnoise;
176:                                 data->inNoise += tempInoise;
186:                     if (data->prtSummary) {
188:                             data->outpVector[data->outNumber++] = noizDens[i];
196:                             data->outpVector[data->outNumber++] = inst->MOS2nVar[OUTNOIZ][i];
197:                             data->outpVector[data->outNumber++] = inst->MOS2nVar[INNOIZ][i];
# /home/ystatter/virunga/spicelib/devices/mos2/mos2load.c
853:                         argv = (vgsx-vbin)/eta-vdsat;
890:                 dldvds = -xlamda-dldvds;
# /home/ystatter/virunga/spicelib/devices/mos2/mos2dset.c
876:                         argv = (vgsx-vbin)/eta-vdsat;
# /home/ystatter/virunga/spicelib/devices/devsup.c
780: extern FILE *slogp;  /* soa log file ('--soa-log file' command line option) */
# /home/ystatter/virunga/spicelib/parser/inpptree.c
522:         *           -->   ((a-b) < 0) ? a : b
957:     data->vals = TMALLOC(scalar, i);
959:     data->n = i;
965:             data->vals[i] = w->right->constant;
969:             data->vals[i] = - w->right->left->constant;
979:     for (i = 0 ; i < data->n ; i += 2)
980:         fprintf(stderr, "  (%lf %lf)\n", data->vals[i], data->vals[i+1]);
983:     for (i = 2 ; i < data->n ; i += 2)
984:         if(data->vals[i-2] >= data->vals[i]) {
1458:             txfree(data->vals);
# /home/ystatter/virunga/spicelib/parser/inppas2.c
51: 	data->error =
52: 	    INPerrCat(data->error,
58: 	data->error =
59: 	    INPerrCat(data->error,
# /home/ystatter/virunga/xspice/evt/evtiter.c
142:     rhs = node_data->rhs;
143:     rhsold = node_data->rhsold;
236:                 node = *(node_data->tail[node_index]);
237:                 node_data->tail[node_index] = &(node->next);
241:                 if(! node_data->modified[node_index]) {
242:                     node_data->modified[node_index] = MIF_TRUE;
243:                     node_data->modified_index[(node_data->num_modified)++] = node_index;
# /home/ystatter/virunga/xspice/evt/evtload.c
194:                 port->total_load = node_data->total_load[port->evt_data.node_index];
269:                 node_data->total_load[port->evt_data.node_index] +=
332:     if(state_data->desc[inst_index] == NULL)
336:     total_size = (size_t) state_data->total_size[inst_index];
339:     if(state_data->free[inst_index]) 
341:         new_state = state_data->free[inst_index];
342:         state_data->free[inst_index] = new_state->next;
354:     prev_state = *(state_data->tail[inst_index]);
357:     state_data->tail[inst_index] = &(prev_state->next);
364:     if(! state_data->modified[inst_index]) {
365:         state_data->modified[inst_index] = MIF_TRUE;
366:         state_data->modified_index[(state_data->num_modified)++] = inst_index;
435:     msg_ptr = msg_data->tail[port_index];
440:         msg_data->tail[port_index] = msg_ptr;
444:     if(msg_data->free[port_index]) {
445:         *msg_ptr = msg_data->free[port_index];
446:         msg_data->free[port_index] = msg_data->free[port_index]->next;
463:         if(! msg_data->modified[port_index]) {
464:             msg_data->modified[port_index] = MIF_TRUE;
465:             msg_data->modified_index[(msg_data->num_modified)++] = port_index;
# /home/ystatter/virunga/xspice/evt/evtbackup.c
156:     num_modified = node_data->num_modified;
160:         node_index = node_data->modified_index[i];
164:         node_ptr = node_data->last_step[node_index];
172:                     tail = *(node_data->tail[node_index]);
173:                     free_head = node_data->free[node_index];
174:                     node_data->free[node_index] = head;
179:                 node_data->tail[node_index] = node_ptr;
189:         from_node = *(node_data->tail[node_index]);
190:         to_node = &(node_data->rhs[node_index]);
192:         to_node = &(node_data->rhsold[node_index]);
199:         node_index = node_data->modified_index[i];
201:         if((*(node_data->last_step[node_index]))->next == NULL) {
202:             node_data->modified[node_index] = MIF_FALSE;
203:             (node_data->num_modified)--;
207:             node_data->modified_index[j] = node_data->modified_index[i];
245:     num_modified = state_data->num_modified;
249:         inst_index = state_data->modified_index[i];
253:         state_ptr = state_data->last_step[inst_index];
261:                     tail = *(state_data->tail[inst_index]);
262:                     free_head = state_data->free[inst_index];
263:                     state_data->free[inst_index] = head;
268:                 state_data->tail[inst_index] = state_ptr;
280:         inst_index = state_data->modified_index[i];
282:         if((*(state_data->last_step[inst_index]))->next == NULL) {
283:             state_data->modified[inst_index] = MIF_FALSE;
284:             (state_data->num_modified)--;
288:             state_data->modified_index[j] = state_data->modified_index[i];
326:     num_modified = msg_data->num_modified;
330:         port_index = msg_data->modified_index[i];
334:         msg_ptr = msg_data->last_step[port_index];
342:                     tail = *(msg_data->tail[port_index]);
343:                     free_head = msg_data->free[port_index];
344:                     msg_data->free[port_index] = head;
349:                 msg_data->tail[port_index] = msg_ptr;
362:         port_index = msg_data->modified_index[i];
364:         if((*(msg_data->last_step[port_index]))->next == NULL) {
365:             msg_data->modified[port_index] = MIF_FALSE;
366:             (msg_data->num_modified)--;
370:             msg_data->modified_index[j] = msg_data->modified_index[i];
# /home/ystatter/virunga/xspice/evt/evtdump.c
156:     rhsold = node_data->rhsold;
157:     head = node_data->head;
285:         num_modified = node_data->num_modified;
288:             index = node_data->modified_index[i];
292:                 here = *(node_data->last_step[index]);
# /home/ystatter/virunga/xspice/evt/evtnode_copy.c
109:         here = node_data->free[node_index];
113:             node_data->free[node_index] = here->next;
# /home/ystatter/virunga/xspice/evt/evtprint.c
263:             if(msg_data->op)
266:                 printf("%-16.9e", msg_data->step);
267:             printf("%s\n", msg_data->text);
268:             msg_data = msg_data->next;
# /home/ystatter/virunga/xspice/evt/evtaccept.c
127:     num_modified = node_data->num_modified;
131:         index = node_data->modified_index[i];
133:         node_data->last_step[index] = node_data->tail[index];
135:         node_data->modified[index] = MIF_FALSE;
138:     node_data->num_modified = 0;
142:     num_modified = state_data->num_modified;
146:         index = state_data->modified_index[i];
148:         state_data->last_step[index] = state_data->tail[index];
150:         state_data->modified[index] = MIF_FALSE;
153:     state_data->num_modified = 0;
157:     num_modified = msg_data->num_modified;
161:         index = msg_data->modified_index[i];
163:         msg_data->last_step[index] = msg_data->tail[index];
165:         msg_data->modified[index] = MIF_FALSE;
168:     msg_data->num_modified = 0;
# /home/ystatter/virunga/xspice/evt/evtsetup.c
311:     CKALLOC(data->node, 1, Evt_Node_Data_t)
312:     CKALLOC(data->state, 1, Evt_State_Data_t)
313:     CKALLOC(data->msg, 1, Evt_Msg_Data_t)
314:     CKALLOC(data->statistics, 1, Evt_Statistic_t)
319:     node_data = data->node;
321:     CKALLOC(node_data->head, num_nodes, Evt_Node_t *)
322:     CKALLOC(node_data->tail, num_nodes, Evt_Node_t **)
323:     CKALLOC(node_data->last_step, num_nodes, Evt_Node_t **)
324:     CKALLOC(node_data->free, num_nodes, Evt_Node_t *)
325:     CKALLOC(node_data->modified_index, num_nodes, int)
326:     CKALLOC(node_data->modified, num_nodes, Mif_Boolean_t)
327:     CKALLOC(node_data->rhs, num_nodes, Evt_Node_t)
328:     CKALLOC(node_data->rhsold, num_nodes, Evt_Node_t)
329:     CKALLOC(node_data->total_load, num_nodes, scalar)
334:         node_data->tail[i] = &(node_data->head[i]);
335:         node_data->last_step[i] = &(node_data->head[i]);
342:         rhs = &(node_data->rhs[i]);
343:         rhsold = &(node_data->rhsold[i]);
374:         node_data->total_load[i] = 0.0;
381:     state_data = data->state;
383:     CKALLOC(state_data->head, num_insts, Evt_State_t *)
384:     CKALLOC(state_data->tail, num_insts, Evt_State_t **)
385:     CKALLOC(state_data->last_step, num_insts, Evt_State_t **)
386:     CKALLOC(state_data->free, num_insts, Evt_State_t *)
387:     CKALLOC(state_data->modified_index, num_insts, int)
388:     CKALLOC(state_data->modified, num_insts, Mif_Boolean_t)
389:     CKALLOC(state_data->total_size, num_insts, int)
390:     CKALLOC(state_data->desc, num_insts, Evt_State_Desc_t *)
393:         state_data->tail[i] = &(state_data->head[i]);
394:         state_data->last_step[i] = &(state_data->head[i]);
401:     msg_data = data->msg;
403:     CKALLOC(msg_data->head, num_ports, Evt_Msg_t *)
404:     CKALLOC(msg_data->tail, num_ports, Evt_Msg_t **)
405:     CKALLOC(msg_data->last_step, num_ports, Evt_Msg_t **)
406:     CKALLOC(msg_data->free, num_ports, Evt_Msg_t *)
407:     CKALLOC(msg_data->modified_index, num_ports, int)
408:     CKALLOC(msg_data->modified, num_ports, Mif_Boolean_t)
411:         msg_data->tail[i] = &(msg_data->head[i]);
412:         msg_data->last_step[i] = &(msg_data->head[i]);
458:     jobs->node_data[i] = data->node;
459:     jobs->state_data[i] = data->state;
460:     jobs->msg_data[i] = data->msg;
461:     jobs->statistics[i] = data->statistics;
543:                         port->input.pvalue = node_data->rhsold[node_index].
547:                         port->input.pvalue = node_data->rhsold[node_index].
561:                         port->output.pvalue = node_data->rhs[node_index].
566:                         port->output.pvalue = node_data->rhs[node_index].
# /home/ystatter/virunga/xspice/evt/evtop.c
235:     rhsold = node_data->rhsold;
236:     head = node_data->head;
# /home/ystatter/virunga/xspice/icm/xtradev/memristor/cfunc.c
118:     return (beta*y+0.5*(alpha-beta)*(fabs(y+vt)-fabs(y-vt)));
# /home/ystatter/virunga/xspice/mif/mifload.c
310:                                 node_data->total_load[fast->evt_data.node_index];
719:     cm_data->circuit.init = MIF_FALSE;
722:     cm_data->circuit.anal_init = MIF_FALSE;
# /home/ystatter/virunga/xspice/cm/cmevt.c
103:     desc_ptr = &(state_data->desc[inst_index]);
123:     desc->offset = state_data->total_size[inst_index];
124:     state_data->total_size[inst_index] += bytes;
127:     state = state_data->head[inst_index];
130:         state_data->head[inst_index] = state;
135:         state->block = tmalloc((size_t) state_data->total_size[inst_index]);
138:                              (size_t) state_data->total_size[inst_index]);
196:     desc = state_data->desc[inst_index];
210:     state = *(state_data->tail[inst_index]);
# /home/ystatter/virunga/main.c
111: FILE *slogp = NULL;          /* soa log file ('--soa-log file' command line option) */
732:        "      --soa-log=FILE        set the outputfile for SOA warnings\n"
# /home/ystatter/virunga/characterize.tcl
89:     regsub -all {([a-zA-Z][a-zA-Z0-9_]*)} $expression {$\1} expression
90:     regsub -all {\$([a-zA-Z][a-zA-Z0-9_]*)\(} $expression {\1(} expression
91:     regsub -all {([0-9])\$([a-zA-Z])} $expression {\1\2} expression
132:         regsub -all {([a-zA-Z][a-zA-Z0-9_]*)=} $expressions {|||\1=} expressions
139:             regsub -all {([a-zA-Z][a-zA-Z0-9_]*)} $expression {$\1} expression
140:             regsub -all {\$([a-zA-Z][a-zA-Z0-9_]*)\(} $expression {\1(} expression
141:             regsub -all {([0-9])\$([a-zA-Z])} $expression {\1\2} expression
# /home/ystatter/virunga/sizer.tcl
139:     while {[regexp {^(.*)%([0-9A-Fa-f][0-9A-Fa-f])(.*)$} $var -> pre code post]} {
282:    regsub -all {\$([A-Za-z_0-9]+)} $code {`$\1`} var_list
285:        if {[regexp {\$([A-Za-z_0-9]+)} $section -> varname]} {
# /home/ystatter/virunga/function_server.tcl
127:     while {[regexp {^(.*)%([0-9A-Fa-f][0-9A-Fa-f])(.*)$} $var -> pre code post]} {
264:    regsub -all {\$([A-Za-z_0-9]+)} $code {`$\1`} var_list
267:        if {[regexp {\$([A-Za-z_0-9]+)} $section -> varname]} {
# /home/ystatter/virunga/rf2tcl.tcl
170:      regsub -all {([A-Za-z_][A-Za-z_0-9]*)\s*=} $args {#\1=} param_line
176:           regsub -all {([a-zA-Z_][a-zA-Z0-9_]*)} $expression {$\1} expression
177:           regsub -all {\$([a-zA-Z_][a-zA-Z0-9_]*)\(} $expression {\1(} expression
178:           regsub -all {([0-9])\$([a-zA-Z])} $expression {\1\2} expression
223: 	regsub -all {([a-zA-Z][a-zA-Z0-9_]*)=} $expressions {|||\1=} expressions
230:              regsub -all {([a-zA-Z][a-zA-Z0-9_]*)} $expression {$\1} expression
231:              regsub -all {\$([a-zA-Z][a-zA-Z0-9_]*)\(} $expression {\1(} expression
232: 	     regsub -all {([0-9])\$([a-zA-Z])} $expression {\1\2} expression
# /home/ystatter/virunga/compile.tcl
140: 	while {[regexp {\$\{(:*[a-zA-Z0-9_]+)\}} $line -> varname] } {
147:         while {[regexp {\$(:*[a-zA-Z0-9_]+)} $line -> varname] } {
191: 	while {[regexp {\$\{(:*[a-zA-Z0-9_]+)\}} $line -> varname] } {
198:         while {[regexp {\$(:*[a-zA-Z0-9_]+)} $line -> varname] } {
